# Full prompt for Cursor AI agent
_Exported on 11/12/2025 at 13:59:19 GMT+2 from Cursor (2.0.69)_

---

**User**

–û—Å—å –ø–æ–≤–Ω–∏–π, –∫—ñ–Ω—Ü–µ–≤–∏–π –ø—Ä–æ–º—Ç –¥–ª—è Cursor AI, —è–∫–∏–π –≤—Ä–∞—Ö–æ–≤—É—î –≤—Å—é –Ω–∞—à—É —Ñ—ñ–Ω–∞–ª—å–Ω—É –∞—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä—É, –æ–±–º–µ–∂–µ–Ω–Ω—è —Ç–∞ –≤–∏–º–æ–≥–∏.



üéØ –ü—Ä–æ–º—Ç –¥–ª—è Cursor AI

–¢–µ–º–∞: –°—Ç–≤–æ—Ä–µ–Ω–Ω—è Python-–∫–æ–¥—É –¥–ª—è –∞–≤—Ç–æ–Ω–æ–º–Ω–æ–≥–æ –ì–µ–Ω–µ—Ä–∞—Ç–∏–≤–Ω–æ–≥–æ AI-–ê–≥–µ–Ω—Ç–∞ –¥–ª—è —Ç–æ—Ä–≥—ñ–≤–ª—ñ, —Ä–æ–∑–≥–æ—Ä–Ω—É—Ç–æ–≥–æ –Ω–∞ Render, –∑ –∫–æ–Ω—Ç—Ä–æ–ª–µ–º —Ä–∏–∑–∏–∫—É —Ç–∞ —Ö–º–∞—Ä–Ω–æ—é –ø–∞–º'—è—Ç—Ç—é.

–†–æ–ª—å: –¢–∏ ‚Äî –µ–ª—ñ—Ç–Ω–∏–π AI-—Ä–æ–∑—Ä–æ–±–Ω–∏–∫, —è–∫–∏–π —Å–ø–µ—Ü—ñ–∞–ª—ñ–∑—É—î—Ç—å—Å—è –Ω–∞ Reinforcement Learning (RL), —Ö–º–∞—Ä–Ω–∏—Ö –∞—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞—Ö —Ç–∞ API –±—ñ—Ä–∂.

–ú–µ—Ç–∞: –°—Ç–≤–æ—Ä–∏—Ç–∏ –ø–æ–≤–Ω–∏–π Python-–ø—Ä–æ—î–∫—Ç –¥–ª—è –ì–µ–Ω–µ—Ä–∞—Ç–∏–≤–Ω–æ–≥–æ AI-–ê–≥–µ–Ω—Ç–∞, —è–∫–∏–π –∞–≤—Ç–æ–Ω–æ–º–Ω–æ (24/7) —Ç–æ—Ä–≥—É—î –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–æ—é –Ω–∞ —Å–ø–æ—Ç–æ–≤–æ–º—É —Ä–∏–Ω–∫—É, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—á–∏ –±–µ–∑–∫–æ—à—Ç–æ–≤–Ω—ñ —Ö–º–∞—Ä–Ω—ñ —Å–µ—Ä–≤—ñ—Å–∏.

1. ‚öôÔ∏è –ö–ª—é—á–æ–≤–∞ –ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞ (–ü–ª–∞—Ç—Ñ–æ—Ä–º–∞ —Ç–∞ –ê–≤—Ç–æ–Ω–æ–º–Ω—ñ—Å—Ç—å)

–ü—Ä–æ–±–ª–µ–º–∞, —è–∫—É –º–∏ –≤–∏—Ä—ñ—à—É—î–º–æ: –í—Å—ñ –±–µ–∑–∫–æ—à—Ç–æ–≤–Ω—ñ –ø—É–±–ª—ñ—á–Ω—ñ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏ (Colab, Kaggle) –±–ª–æ–∫—É—é—Ç—å—Å—è API –±—ñ—Ä–∂ (Binance, Bybit) —á–µ—Ä–µ–∑ IP-–∞–¥—Ä–µ—Å–∏ (–ø–æ–º–∏–ª–∫–∏ 403/451).

–ù–∞—à–µ –†—ñ—à–µ–Ω–Ω—è (–û–±–æ–≤'—è–∑–∫–æ–≤–µ):

 * –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞: –ú–∏ –±—É–¥–µ–º–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ Render (Free Tier).

 * –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ö–æ–¥—É: –ê–≥–µ–Ω—Ç –º–∞—î –±—É—Ç–∏ –∑–∞–≥–æ—Ä–Ω—É—Ç–∏–π —É –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π –≤–µ–±-—Å–µ—Ä–≤–µ—Ä Flask –∑ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è–º Gunicorn.

 * –ê–≤—Ç–æ–Ω–æ–º–Ω—ñ—Å—Ç—å 24/7: –ö–æ–¥ –ø–æ–≤–∏–Ω–µ–Ω –≤–∫–ª—é—á–∞—Ç–∏ "Keep-Alive" –µ–Ω–¥–ø–æ—ñ–Ω—Ç (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, @app.route('/')). –¶–µ–π –µ–Ω–¥–ø–æ—ñ–Ω—Ç –±—É–¥–µ –ø—ñ–Ω–≥—É–≤–∞—Ç–∏—Å—è –∫–æ–∂–Ω—ñ 5-10 —Ö–≤–∏–ª–∏–Ω –∑–æ–≤–Ω—ñ—à–Ω—ñ–º —Å–µ—Ä–≤—ñ—Å–æ–º UptimeRobot (Free Plan), —â–æ–± –∑–∞–ø–æ–±—ñ–≥—Ç–∏ "–∑–∞—Å–∏–Ω–∞–Ω–Ω—é" –±–µ–∑–∫–æ—à—Ç–æ–≤–Ω–æ–≥–æ —ñ–Ω—Å—Ç–∞–Ω—Å—É Render.

 * –§–æ–Ω–æ–≤–∏–π –ü—Ä–æ—Ü–µ—Å: –û—Å–Ω–æ–≤–Ω–∞ –ª–æ–≥—ñ–∫–∞ AI-–ê–≥–µ–Ω—Ç–∞ (—Ü–∏–∫–ª —Ç–æ—Ä–≥—ñ–≤–ª—ñ —Ç–∞ –Ω–∞–≤—á–∞–Ω–Ω—è) –º–∞—î –ø—Ä–∞—Ü—é–≤–∞—Ç–∏ —É —Ñ–æ–Ω–æ–≤–æ–º—É –ø–æ—Ç–æ—Ü—ñ (threading), –Ω–µ–∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞ Flask.

2. üß† –ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞ AI-–ê–≥–µ–Ω—Ç–∞ ("–ú–æ–∑–æ–∫" —Ç–∞ "–°—É–ø–µ—Ä–≤—ñ–∑–æ—Ä")

–í–∏–º–æ–≥–∞: –¶–µ –º–∞—î –±—É—Ç–∏ –ì–µ–Ω–µ—Ä–∞—Ç–∏–≤–Ω–∏–π AI-–ê–≥–µ–Ω—Ç (–Ω–µ –Ω–∞–ø—ñ–≤–∞–≤—Ç–æ–º–∞—Ç), —è–∫–∏–π –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î Reinforcement Learning (RL) –¥–ª—è —Å–∞–º–æ—Å—Ç—ñ–π–Ω–æ–≥–æ –∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è —Ç–∞ –≤–¥–æ—Å–∫–æ–Ω–∞–ª–µ–Ω–Ω—è —Ç–æ—Ä–≥–æ–≤–∏—Ö —Å—Ç—Ä–∞—Ç–µ–≥—ñ–π.

–î–∂–µ—Ä–µ–ª–∞ –î–∞–Ω–∏—Ö (–ê–≤—Ç–æ–Ω–æ–º–Ω—ñ):

 * –¢–µ—Ö–Ω—ñ—á–Ω–∏–π –ê–Ω–∞–ª—ñ–∑ (–¢–ê): –ê–≥–µ–Ω—Ç –ø–æ–≤–∏–Ω–µ–Ω —Å–∞–º–æ—Å—Ç—ñ–π–Ω–æ –∞–Ω–∞–ª—ñ–∑—É–≤–∞—Ç–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ñ —ñ–Ω–¥–∏–∫–∞—Ç–æ—Ä–∏ –¢–ê (RSI, MA, Volume, –í–æ–ª–∞—Ç–∏–ª—å–Ω—ñ—Å—Ç—å) –∑ API –±—ñ—Ä–∂—ñ.

 * –û—Ü–∏—Ñ—Ä–æ–≤–∞–Ω–∏–π –§–ê: –ê–≥–µ–Ω—Ç –ø–æ–≤–∏–Ω–µ–Ω –∞–Ω–∞–ª—ñ–∑—É–≤–∞—Ç–∏ –æ—Ü–∏—Ñ—Ä–æ–≤–∞–Ω—ñ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ñ –¥–∞–Ω—ñ, –¥–æ—Å—Ç—É–ø–Ω—ñ —á–µ—Ä–µ–∑ API, —è–∫—ñ –≤—ñ–¥–æ–±—Ä–∞–∂–∞—é—Ç—å "–Ω–∞—Å—Ç—Ä—ñ–π" —Ä–∏–Ω–∫—É. (–ù–∞–ø—Ä–∏–∫–ª–∞–¥: –≥–ª–∏–±–∏–Ω–∞ –∫–Ω–∏–≥–∏ –æ—Ä–¥–µ—Ä—ñ–≤, –∞–Ω–æ–º–∞–ª—ñ—ó –æ–±—Å—è–≥—ñ–≤, —Å–ø—ñ–≤–≤—ñ–¥–Ω–æ—à–µ–Ω–Ω—è –æ—Ä–¥–µ—Ä—ñ–≤ –Ω–∞ –∫—É–ø—ñ–≤–ª—é/–ø—Ä–æ–¥–∞–∂). –ñ–æ–¥–Ω–æ–≥–æ NLP —á–∏ —Ä—É—á–Ω–æ–≥–æ –≤–≤–µ–¥–µ–Ω–Ω—è –Ω–æ–≤–∏–Ω.

–î–≤–æ—Ä—ñ–≤–Ω–µ–≤–∞ –°–∏—Å—Ç–µ–º–∞ –ë–µ–∑–ø–µ–∫–∏ ("–°—É–ø–µ—Ä–≤—ñ–∑–æ—Ä"):

 * –†—ñ–≤–µ–Ω—å 1 (–í–∏–±—ñ—Ä –ö–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞): –ü–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –º–∞—î –≤—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ –æ–¥–∏–Ω —ñ–∑ —Ç—Ä—å–æ—Ö –±–∞–∑–æ–≤–∏—Ö —Ä–µ–∂–∏–º—ñ–≤:

   * CONSERVATIVE

   * BALANCED

   * AGGRESSIVE

 * –†—ñ–≤–µ–Ω—å 2 (–ö–æ–Ω—Ç—Ä–æ–ª—å AI): AI-–°—É–ø–µ—Ä–≤—ñ–∑–æ—Ä –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∫–æ—Ä–∏–≥—É—î —Ä–∏–∑–∏–∫, –∞–ª–µ –ª–∏—à–µ –≤ –±—ñ–∫ –∑–Ω–∏–∂–µ–Ω–Ω—è, –±–∞–∑—É—é—á–∏—Å—å –Ω–∞ –∞–Ω–∞–ª—ñ–∑—ñ —Ä–∏–Ω–∫—É (–§–ê+–¢–ê).

   * –õ–æ–≥—ñ–∫–∞:

     * –Ø–∫—â–æ –æ–±—Ä–∞–Ω–æ CONSERVATIVE: AI –Ω–µ –º–æ–∂–µ –∑–º—ñ–Ω—é–≤–∞—Ç–∏ —Å—Ç–∏–ª—å.

     * –Ø–∫—â–æ –æ–±—Ä–∞–Ω–æ BALANCED: AI –º–æ–∂–µ –ª–∏—à–µ –∑–Ω–∏–∑–∏—Ç–∏ —Ä–∏–∑–∏–∫ –¥–æ BALANCED_CONSERVATIVE –∞–±–æ CONSERVATIVE.

     * –Ø–∫—â–æ –æ–±—Ä–∞–Ω–æ AGGRESSIVE: AI –º–æ–∂–µ –¥–∏–Ω–∞–º—ñ—á–Ω–æ –∑–Ω–∏–∂—É–≤–∞—Ç–∏ —Ä–∏–∑–∏–∫ –¥–æ BALANCED_AGGRESSIVE, BALANCED, CONSERVATIVE —ñ —Ç.–¥., –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ "—à—É–º—É" –Ω–∞ —Ä–∏–Ω–∫—É.

   * AI –Ω—ñ–∫–æ–ª–∏ –Ω–µ –º–æ–∂–µ –ø—ñ–¥–≤–∏—â–∏—Ç–∏ —Ä–∏–∑–∏–∫ –≤–∏—â–µ –±–∞–∑–æ–≤–æ–≥–æ —Ä—ñ–≤–Ω—è, –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ–≥–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–µ–º.

3. üìà –¢–æ—Ä–≥—ñ–≤–ª—è —Ç–∞ –°–ø–µ—Ü–∏—Ñ—ñ—á–Ω–∏–π –†–∏–∑–∏–∫

 * –†–∏–Ω–æ–∫: –°–ø–æ—Ç–æ–≤–∞ —Ç–æ—Ä–≥—ñ–≤–ª—è (Spot Trading). (–ñ–æ–¥–Ω–∏—Ö —Ñ'—é—á–µ—Ä—Å—ñ–≤, –∂–æ–¥–Ω–æ–≥–æ –∫—Ä–µ–¥–∏—Ç–Ω–æ–≥–æ –ø–ª–µ—á–∞).

 * –ë—ñ—Ä–∂–∞: –ö–æ–¥ –º–∞—î –±—É—Ç–∏ –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–∏–π –¥–ª—è Binance Testnet (–∞–±–æ Bybit Testnet, —è–∫—â–æ –≤—ñ–Ω –ø—ñ–¥—Ç—Ä–∏–º—É—î —Å–ø–æ—Ç).

 * –ê–∫—Ç–∏–≤–∏: –ê–≥–µ–Ω—Ç —Ñ–æ–∫—É—Å—É—î—Ç—å—Å—è –ª–∏—à–µ –Ω–∞ BTC/USDT —Ç–∞ ETH/USDT. (–ù–∞–¥–∞–π –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å –ø–æ—á–∞—Ç–∫–æ–≤–æ–≥–æ –≤–∏–±–æ—Ä—É –ø–∞—Ä–∏ –∞–±–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ–≥–æ –ø–µ—Ä–µ–º–∏–∫–∞–Ω–Ω—è AI, —è–∫—â–æ —Ü–µ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ).

 * –ü—Ä–∞–≤–∏–ª–æ –ê–≥—Ä–µ—Å–∏–≤–Ω–æ–≥–æ –†–µ–∂–∏–º—É: –ù–∞–≤—ñ—Ç—å —É —Ä–µ–∂–∏–º—ñ AGGRESSIVE, –°—É–ø–µ—Ä–≤—ñ–∑–æ—Ä –ø–æ–≤–∏–Ω–µ–Ω –≥–∞—Ä–∞–Ω—Ç—É–≤–∞—Ç–∏, —â–æ –∞–≥–µ–Ω—Ç –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î –Ω–µ –±—ñ–ª—å—à–µ 30% –≤—ñ–¥ –∑–∞–≥–∞–ª—å–Ω–æ–≥–æ –¥–µ–ø–æ–∑–∏—Ç—É –¥–ª—è —Ç–æ—Ä–≥—ñ–≤–ª—ñ, –∑–∞–ª–∏—à–∞—é—á–∏ 70% —É —Ä–µ–∑–µ—Ä–≤—ñ –¥–ª—è –∑–∞—Ö–∏—Å—Ç—É –≤—ñ–¥ "—á–æ—Ä–Ω–∏—Ö –ª–µ–±–µ–¥—ñ–≤".

4. üíæ –•–º–∞—Ä–Ω–∞ –ü–∞–º'—è—Ç—å (–ë–µ–∑ –õ–æ–∫–∞–ª—å–Ω–æ–≥–æ –î–∏—Å–∫–∞)

–í–∏–º–æ–≥–∞: –û—Å–∫—ñ–ª—å–∫–∏ —Ñ–∞–π–ª–æ–≤–∞ —Å–∏—Å—Ç–µ–º–∞ Render —î —Ç–∏–º—á–∞—Å–æ–≤–æ—é, "–º–æ–∑–æ–∫" AI-–ê–≥–µ–Ω—Ç–∞ (–Ω–∞–≤—á–µ–Ω–∞ –º–æ–¥–µ–ª—å, model.h5 –∞–±–æ .pt) –ø–æ–≤–∏–Ω–µ–Ω –∑–±–µ—Ä—ñ–≥–∞—Ç–∏—Å—è —Ç–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂—É–≤–∞—Ç–∏—Å—è –∑ —Ö–º–∞—Ä–∏.

 * –†—ñ—à–µ–Ω–Ω—è: –Ü–Ω—Ç–µ–≥—Ä—É–π —É –∫–æ–¥ —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª –¥–ª—è —Ä–æ–±–æ—Ç–∏ –∑ Google Drive API.

 * –õ–æ–≥—ñ–∫–∞:

   * –ê–≥–µ–Ω—Ç –ø–æ–≤–∏–Ω–µ–Ω –º–∞—Ç–∏ —Ñ—É–Ω–∫—Ü—ñ—é load_model_from_drive(), —è–∫–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î client_secrets.json (OAuth 2.0) —Ç–∞ PyDrive (–∞–±–æ –∞–Ω–∞–ª–æ–≥) –¥–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—É –º–æ–¥–µ–ª—ñ –∑ Google Drive –ø—Ä–∏ —Å—Ç–∞—Ä—Ç—ñ.                                               * –ê–≥–µ–Ω—Ç –ø–æ–≤–∏–Ω–µ–Ω –º–∞—Ç–∏ —Ñ—É–Ω–∫—Ü—ñ—é save_model_to_drive(), —è–∫–∞ –ø–µ—Ä—ñ–æ–¥–∏—á–Ω–æ (–∞–±–æ –ø—ñ—Å–ª—è —É—Å–ø—ñ—à–Ω–æ–≥–æ –Ω–∞–≤—á–∞–Ω–Ω—è) –∑–∞–≤–∞–Ω—Ç–∞–∂—É—î –æ–Ω–æ–≤–ª–µ–Ω–∏–π —Ñ–∞–π–ª –º–æ–¥–µ–ª—ñ –Ω–∞–∑–∞–¥ –Ω–∞ Google Drive.

üìã –ó–∞–≤–¥–∞–Ω–Ω—è:

 * –°—Ç–≤–æ—Ä–∏ requirements.txt: (–í–∫–ª—é—á–∏ Flask, gunicorn, ccxt, pandas, tensorflow –∞–±–æ pytorch, pydrive –∞–±–æ google-api-python-client).

 * –°—Ç–≤–æ—Ä–∏ app.py: –¶–µ –º–∞—î –±—É—Ç–∏ –ø–æ–≤–Ω–∏–π, –≥–æ—Ç–æ–≤–∏–π –¥–æ —Ä–æ–∑–≥–æ—Ä—Ç–∞–Ω–Ω—è Flask-–¥–æ–¥–∞—Ç–æ–∫, —è–∫–∏–π –≤–∫–ª—é—á–∞—î:

   * –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è Flask —Ç–∞ Gunicorn.

   * –ï–Ω–¥–ø–æ—ñ–Ω—Ç / –¥–ª—è UptimeRobot.

   * –ó–∞–ø—É—Å–∫ —Ñ–æ–Ω–æ–≤–æ–≥–æ –ø–æ—Ç–æ–∫—É (threading) –¥–ª—è AI-–ê–≥–µ–Ω—Ç–∞.

   * –ü–æ–≤–Ω—É –∞—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä—É AI-–ê–≥–µ–Ω—Ç–∞ (–ú–æ–∑–æ–∫ + –°—É–ø–µ—Ä–≤—ñ–∑–æ—Ä) –∑ –ª–æ–≥—ñ–∫–æ—é —Ç—Ä—å–æ—Ö —Ä–µ–∂–∏–º—ñ–≤ —Ä–∏–∑–∏–∫—É —Ç–∞ –æ–±–º–µ–∂–µ–Ω–Ω—è–º 30/70.

   * –Ü–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—é –∑ Google Drive API (—Ñ—É–Ω–∫—Ü—ñ—ó load —Ç–∞ save).

   * –ü—Ä–∏–∫–ª–∞–¥ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ ccxt (Binance Testnet Spot) —Ç–∞ —Ü–∏–∫–ª —Ç–æ—Ä–≥—ñ–≤–ª—ñ.

---

**Cursor**

```plaintext
Flask==3.0.3
gunicorn==21.2.0
ccxt==4.3.75
pandas==2.2.2
numpy==1.26.4
scipy==1.11.4
tensorflow==2.15.0
google-api-python-client==2.149.0
google-auth==2.35.0
google-auth-oauthlib==1.2.1
google-auth-httplib2==0.2.0
httplib2==0.22.0
python-dotenv==1.0.1
# –û—Å–Ω–æ–≤–Ω—ñ –∑–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ
asyncio
aiohttp>=3.8.0
asyncpg>=0.28.0
ccxt>=4.0.0
streamlit>=1.28.0
plotly>=5.15.0
pandas>=2.0.0
numpy>=1.24.0

# Telegram –±–æ—Ç (–Ω–æ–≤–∞ –≤–µ—Ä—Å—ñ—è –∑ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∏–º API)
python-telegram-bot>=20.0
requests>=2.28.0

# AI —ñ–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è (Google Gemini)
google-genai>=0.2.0

# –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è
optuna>=3.3.0

# –î–æ–¥–∞—Ç–∫–æ–≤—ñ —É—Ç–∏–ª—ñ—Ç–∏
python-dotenv>=1.0.0
pydantic>=2.0.0
loguru>=0.7.0

# –¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è
pytest>=7.4.0
pytest-asyncio>=0.21.0
pytest-mock>=3.11.0

# –†–æ–∑—Ä–æ–±–∫–∞
black>=23.0.0
flake8>=6.0.0
mypy>=1.5.0
```

```python
import json
import logging
import os
import threading
import time
from dataclasses import dataclass
from datetime import datetime, timezone
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import ccxt
import numpy as np
import pandas as pd
import tensorflow as tf
from flask import Flask, jsonify, request
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from google.auth.transport.requests import Request as GoogleAuthRequest


# ------------------------------------------------------------------------------
# Configuration & Logging
# ------------------------------------------------------------------------------

logging.basicConfig(
    level=os.getenv("LOG_LEVEL", "INFO"),
    format="%(asctime)s [%(levelname)s] %(threadName)s %(message)s",
)
logger = logging.getLogger(__name__)

MODEL_FILE_NAME = os.getenv("MODEL_FILE_NAME", "agent_model.keras")
MODEL_DRIVE_FILE_ID = os.getenv("MODEL_DRIVE_FILE_ID")
CLIENT_SECRETS_FILE = os.getenv("CLIENT_SECRETS_FILE", "client_secrets.json")
TOKEN_FILE = os.getenv("GOOGLE_TOKEN_FILE", "token.json")
DRIVE_SCOPES = ["https://www.googleapis.com/auth/drive.file"]

CCXT_API_KEY = os.getenv("BINANCE_TESTNET_API_KEY")
CCXT_SECRET_KEY = os.getenv("BINANCE_TESTNET_SECRET_KEY")

DEFAULT_SYMBOLS = ["BTC/USDT", "ETH/USDT"]
POLL_INTERVAL_SECONDS = int(os.getenv("POLL_INTERVAL_SECONDS", "60"))
SAVE_MODEL_INTERVAL_STEPS = int(os.getenv("SAVE_MODEL_INTERVAL_STEPS", "30"))
TRAIN_BATCH_SIZE = int(os.getenv("TRAIN_BATCH_SIZE", "32"))
MAX_EPISODE_LENGTH = int(os.getenv("MAX_EPISODE_LENGTH", "96"))  # roughly 96 minutes


# ------------------------------------------------------------------------------
# Risk Management
# ------------------------------------------------------------------------------


class RiskBand(Enum):
    CONSERVATIVE = "CONSERVATIVE"
    BALANCED_CONSERVATIVE = "BALANCED_CONSERVATIVE"
    BALANCED = "BALANCED"
    BALANCED_AGGRESSIVE = "BALANCED_AGGRESSIVE"
    AGGRESSIVE = "AGGRESSIVE"

    @property
    def max_position_fraction(self) -> float:
        mapping = {
            RiskBand.CONSERVATIVE: 0.10,
            RiskBand.BALANCED_CONSERVATIVE: 0.15,
            RiskBand.BALANCED: 0.20,
            RiskBand.BALANCED_AGGRESSIVE: 0.25,
            RiskBand.AGGRESSIVE: 0.30,
        }
        return mapping[self]


RISK_DOWNGRADE_PATHS: Dict[RiskBand, List[RiskBand]] = {
    RiskBand.CONSERVATIVE: [RiskBand.CONSERVATIVE],
    RiskBand.BALANCED: [
        RiskBand.BALANCED,
        RiskBand.BALANCED_CONSERVATIVE,
        RiskBand.CONSERVATIVE,
    ],
    RiskBand.AGGRESSIVE: [
        RiskBand.AGGRESSIVE,
        RiskBand.BALANCED_AGGRESSIVE,
        RiskBand.BALANCED,
        RiskBand.BALANCED_CONSERVATIVE,
        RiskBand.CONSERVATIVE,
    ],
}


class Supervisor:
    """AI supervisor that enforces multi-level risk governance."""

    def __init__(self, user_selected: RiskBand):
        self.user_selected = user_selected
        self.current_band = user_selected

    def evaluate_market_noise(
        self,
        vol_ratio: float,
        book_pressure: float,
        trend_strength: float,
    ) -> RiskBand:
        """
        Decide on a safer risk band depending on market conditions.
        Higher volatility or imbalanced books => lower risk.
        """
        candidates = RISK_DOWNGRADE_PATHS[self.user_selected]
        score = (vol_ratio * 0.5) + (abs(book_pressure) * 0.3) - (abs(trend_strength) * 0.2)
        logger.debug("Supervisor noise score %.4f", score)

        if score > 1.5 and len(candidates) > 1:
            self.current_band = candidates[-1]
        elif score > 1.0 and len(candidates) > 2:
            self.current_band = candidates[-2]
        elif score > 0.7 and len(candidates) > 3:
            self.current_band = candidates[-3]
        else:
            self.current_band = candidates[0]

        logger.info("Supervisor risk band -> %s", self.current_band.value)
        return self.current_band


# ------------------------------------------------------------------------------
# Google Drive Persistence
# ------------------------------------------------------------------------------


class CloudModelManager:
    def __init__(
        self,
        client_secrets_path: str,
        token_path: str,
        drive_file_id: Optional[str],
    ) -> None:
        self.client_secrets_path = client_secrets_path
        self.token_path = token_path
        self.drive_file_id = drive_file_id
        self._service = None

    def _get_credentials(self) -> Credentials:
        if not Path(self.client_secrets_path).exists():
            raise FileNotFoundError(
                f"client_secrets.json –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –∑–∞ —à–ª—è—Ö–æ–º {self.client_secrets_path}"
            )

        creds: Optional[Credentials] = None
        token_file = Path(self.token_path)
        if token_file.exists():
            creds = Credentials.from_authorized_user_file(self.token_path, DRIVE_SCOPES)

        if not creds or not creds.valid:
            if creds and creds.expired and creds.refresh_token:
                logger.info("–û–Ω–æ–≤–ª–µ–Ω–Ω—è Google Drive —Ç–æ–∫–µ–Ω–∞")
                creds.refresh(GoogleAuthRequest())
            else:
                from google_auth_oauthlib.flow import InstalledAppFlow

                flow = InstalledAppFlow.from_client_secrets_file(
                    self.client_secrets_path,
                    DRIVE_SCOPES,
                )
                logger.info("–ó–∞–ø—É—Å–∫ OAuth-—Ñ–ª–æ—É –¥–ª—è Google Drive")
                creds = flow.run_console()
            token_file.write_text(creds.to_json(), encoding="utf-8")

        return creds

    def _get_service(self):
        if self._service is None:
            creds = self._get_credentials()
            self._service = build("drive", "v3", credentials=creds, cache_discovery=False)
        return self._service

    def load_model(self, local_path: str) -> bool:
        if not self.drive_file_id:
            logger.warning("MODEL_DRIVE_FILE_ID –Ω–µ –∑–∞–¥–∞–Ω–∏–π; –ø—Ä–æ–ø—É—Å–∫–∞—é –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –º–æ–¥–µ–ª—ñ")
            return False

        service = self._get_service()
        try:
            logger.info("–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –º–æ–¥–µ–ª—ñ –∑ Google Drive (%s)", self.drive_file_id)
            request = service.files().get_media(fileId=self.drive_file_id)
            fh = tf.io.gfile.GFile(local_path, "wb")
            downloader = googleapiclient.http.MediaIoBaseDownload(fh, request)
            done = False
            while not done:
                status, done = downloader.next_chunk()
                if status:
                    logger.debug("–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ %.2f%%", status.progress() * 100)
            fh.close()
            return True
        except HttpError as exc:
            logger.error("–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –º–æ–¥–µ–ª—å: %s", exc)
            return False

    def save_model(self, local_path: str) -> Optional[str]:
        service = self._get_service()
        if not Path(local_path).exists():
            logger.warning("–ù–µ–º–∞—î —Ñ–∞–π–ª—É –º–æ–¥–µ–ª—ñ %s –¥–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è", local_path)
            return self.drive_file_id

        metadata = {
            "name": MODEL_FILE_NAME,
            "mimeType": "application/octet-stream",
        }
        media = googleapiclient.http.MediaFileUpload(local_path, resumable=True)

        try:
            if self.drive_file_id:
                logger.info("–û–Ω–æ–≤–ª–µ–Ω–Ω—è –º–æ–¥–µ–ª—ñ –Ω–∞ Google Drive (%s)", self.drive_file_id)
                updated = (
                    service.files()
                    .update(fileId=self.drive_file_id, media_body=media, body=metadata)
                    .execute()
                )
            else:
                logger.info("–°—Ç–≤–æ—Ä–µ–Ω–Ω—è –Ω–æ–≤–æ–≥–æ —Ñ–∞–π–ª—É –º–æ–¥–µ–ª—ñ –Ω–∞ Google Drive")
                updated = service.files().create(media_body=media, body=metadata).execute()

            self.drive_file_id = updated.get("id")
            os.environ["MODEL_DRIVE_FILE_ID"] = self.drive_file_id
            return self.drive_file_id
        except HttpError as exc:
            logger.error("–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–±–µ—Ä–µ–≥—Ç–∏ –º–æ–¥–µ–ª—å –Ω–∞ Google Drive: %s", exc)
            return None


# ------------------------------------------------------------------------------
# Market Data & Execution
# ------------------------------------------------------------------------------


def build_exchange() -> ccxt.Exchange:
    exchange = ccxt.binance(
        {
            "enableRateLimit": True,
            "apiKey": CCXT_API_KEY,
            "secret": CCXT_SECRET_KEY,
            "timeout": 30000,
            "options": {"defaultType": "spot"},
        }
    )
    exchange.set_sandbox_mode(True)
    return exchange


class MarketDataFetcher:
    def __init__(self, exchange: ccxt.Exchange, symbols: List[str]):
        self.exchange = exchange
        self.symbols = symbols

    def get_recent_ohlcv(self, symbol: str, since_ms: Optional[int] = None) -> pd.DataFrame:
        ohlcv = self.exchange.fetch_ohlcv(symbol, timeframe="1m", since=since_ms, limit=200)
        df = pd.DataFrame(
            ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"]
        )
        df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms", utc=True)
        return df

    def get_ta_features(self, df: pd.DataFrame) -> Dict[str, float]:
        if df.empty:
            return {"rsi": 50.0, "ma_fast": 0.0, "ma_slow": 0.0, "volatility": 0.0}

        close = df["close"]
        delta = close.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rs = gain / (loss + 1e-9)
        rsi = 100 - (100 / (1 + rs.iloc[-1]))

        ma_fast = close.rolling(window=10).mean().iloc[-1]
        ma_slow = close.rolling(window=30).mean().iloc[-1]
        volatility = close.pct_change().rolling(window=30).std().iloc[-1]

        return {
            "rsi": float(np.nan_to_num(rsi, nan=50.0)),
            "ma_fast": float(np.nan_to_num(ma_fast, nan=close.iloc[-1])),
            "ma_slow": float(np.nan_to_num(ma_slow, nan=close.iloc[-1])),
            "volatility": float(np.nan_to_num(volatility, nan=0.0)),
        }

    def get_order_book_metrics(self, symbol: str) -> Dict[str, float]:
        order_book = self.exchange.fetch_order_book(symbol)
        bids = np.array(order_book["bids"][:20])
        asks = np.array(order_book["asks"][:20])
        bid_volume = bids[:, 1].sum() if bids.size else 0.0
        ask_volume = asks[:, 1].sum() if asks.size else 0.0
        imbalance = (bid_volume - ask_volume) / (bid_volume + ask_volume + 1e-9)
        return {
            "bid_volume": float(bid_volume),
            "ask_volume": float(ask_volume),
            "imbalance": float(imbalance),
        }


class TradeExecutor:
    def __init__(self, exchange: ccxt.Exchange, supervisor: Supervisor):
        self.exchange = exchange
        self.supervisor = supervisor

    def get_balance(self, asset: str) -> float:
        balance = self.exchange.fetch_balance()
        return float(balance.get(asset, {}).get("free", 0.0))

    def execute(self, symbol: str, side: str, amount: float) -> Optional[Dict[str, Any]]:
        try:
            logger.info("–í–∏–∫–æ–Ω–∞–Ω–Ω—è –æ—Ä–¥–µ—Ä—É %s %s %.6f", symbol, side, amount)
            if amount <= 0:
                return None
            order = self.exchange.create_market_order(symbol, side.lower(), amount)
            return order
        except Exception as exc:  # noqa: BLE001
            logger.error("–ü–æ–º–∏–ª–∫–∞ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –æ—Ä–¥–µ—Ä—É: %s", exc)
            return None

    def max_position_size(self, usdt_balance: float) -> float:
        allowed_fraction = self.supervisor.current_band.max_position_fraction
        return usdt_balance * allowed_fraction


# ------------------------------------------------------------------------------
# Reinforcement Learning Agent
# ------------------------------------------------------------------------------


class TradingEnvironment:
    def __init__(self, data_fetcher: MarketDataFetcher, symbols: List[str]):
        self.data_fetcher = data_fetcher
        self.symbols = symbols
        self.last_prices: Dict[str, float] = {s: 0.0 for s in symbols}

    def get_state(self) -> Tuple[np.ndarray, str]:
        symbol = self._select_symbol()
        df = self.data_fetcher.get_recent_ohlcv(symbol)
        ta = self.data_fetcher.get_ta_features(df)
        book = self.data_fetcher.get_order_book_metrics(symbol)
        latest_price = df["close"].iloc[-1] if not df.empty else self.last_prices[symbol]
        self.last_prices[symbol] = latest_price

        state_vector = np.array(
            [
                ta["rsi"] / 100.0,
                (ta["ma_fast"] - ta["ma_slow"]) / (latest_price + 1e-9),
                ta["volatility"],
                book["imbalance"],
            ],
            dtype=np.float32,
        )
        market_context = {
            "vol_ratio": max(ta["volatility"], 1e-6) * 100,
            "book_pressure": book["imbalance"],
            "trend_strength": ta["ma_fast"] - ta["ma_slow"],
        }
        return state_vector, symbol, market_context

    def _select_symbol(self) -> str:
        weights = []
        for symbol in self.symbols:
            df = self.data_fetcher.get_recent_ohlcv(symbol)
            if df.empty:
                weights.append(1.0)
            else:
                weights.append(df["volume"].iloc[-30:].mean())
        total = sum(weights)
        weights = [w / total if total else 1 / len(self.symbols) for w in weights]
        return np.random.choice(self.symbols, p=weights)


class ActorCriticAgent:
    def __init__(self, state_dim: int, action_dim: int, learning_rate: float = 1e-4):
        self.state_dim = state_dim
        self.action_dim = action_dim
        self.gamma = 0.99
        self.learning_rate = learning_rate
        self.model = self._build_model()
        self.optimizer = tf.keras.optimizers.Adam(learning_rate=self.learning_rate)

    def _build_model(self) -> tf.keras.Model:
        inputs = tf.keras.Input(shape=(self.state_dim,))
        dense1 = tf.keras.layers.Dense(64, activation="relu")(inputs)
        dense2 = tf.keras.layers.Dense(64, activation="relu")(dense1)
        policy_logits = tf.keras.layers.Dense(self.action_dim, activation="linear")(dense2)
        value = tf.keras.layers.Dense(1, activation="linear")(dense2)
        model = tf.keras.Model(inputs=inputs, outputs=[policy_logits, value])
        model.compile()
        return model

    def select_action(self, state: np.ndarray) -> Tuple[int, float]:
        state = np.expand_dims(state, axis=0)
        logits, value = self.model(state, training=False)
        logits = logits.numpy()[0]
        probs = tf.nn.softmax(logits).numpy()
        action = np.random.choice(self.action_dim, p=probs)
        return int(action), float(value.numpy()[0][0])

    def train_batch(
        self,
        states: np.ndarray,
        actions: np.ndarray,
        advantages: np.ndarray,
        returns: np.ndarray,
    ) -> float:
        with tf.GradientTape() as tape:
            logits, values = self.model(states, training=True)
            values = tf.squeeze(values, axis=1)
            value_loss = tf.reduce_mean(tf.square(returns - values))
            policy = tf.nn.log_softmax(logits)
            indices = tf.stack([tf.range(tf.shape(actions)[0]), actions], axis=1)
            picked_log_probs = tf.gather_nd(policy, indices)
            policy_loss = -tf.reduce_mean(picked_log_probs * advantages)
            entropy = -tf.reduce_mean(tf.exp(policy) * policy)
            loss = policy_loss + 0.5 * value_loss - 0.01 * entropy

        grads = tape.gradient(loss, self.model.trainable_variables)
        self.optimizer.apply_gradients(zip(grads, self.model.trainable_variables))
        return float(loss.numpy())

    def save(self, path: str) -> None:
        self.model.save(path)

    def load(self, path: str) -> None:
        if Path(path).exists():
            self.model = tf.keras.models.load_model(path)
            logger.info("–ú–æ–¥–µ–ª—å –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ –∑ %s", path)
        else:
            logger.warning("–§–∞–π–ª –º–æ–¥–µ–ª—ñ %s –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é –ø–µ—Ä–≤—ñ—Å–Ω—É –º–æ–¥–µ–ª—å", path)


# ------------------------------------------------------------------------------
# Trading Orchestrator
# ------------------------------------------------------------------------------


class TradingAgentRunner:
    def __init__(
        self,
        supervisor: Supervisor,
        environment: TradingEnvironment,
        executor: TradeExecutor,
        cloud_manager: CloudModelManager,
        symbol_deposit: Dict[str, float],
    ):
        self.supervisor = supervisor
        self.environment = environment
        self.executor = executor
        self.cloud_manager = cloud_manager
        self.symbol_deposit = symbol_deposit
        self.agent = ActorCriticAgent(state_dim=4, action_dim=3)
        self.replay_buffer: List[Tuple[np.ndarray, int, float, float]] = []
        self.step_counter = 0

    def bootstrap(self):
        try:
            if self.cloud_manager.load_model(MODEL_FILE_NAME):
                self.agent.load(MODEL_FILE_NAME)
            else:
                logger.info("–ó–∞–ø—É—Å–∫–∞—é –∞–≥–µ–Ω—Ç–∞ –∑ –≤–∏–ø–∞–¥–∫–æ–≤–∏–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏")
        except Exception as exc:  # noqa: BLE001
            logger.error("–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –º–æ–¥–µ–ª—å: %s", exc)

    def _calculate_position(self, symbol: str, risk_band: RiskBand) -> float:
        base, quote = symbol.split("/")
        usdt_balance = self.executor.get_balance(quote)
        max_position = self.executor.max_position_size(usdt_balance)
        price = self.environment.last_prices.get(symbol) or self.executor.exchange.fetch_ticker(
            symbol
        )["last"]
        amount = max_position / price
        logger.debug(
            "–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –ø–æ–∑–∏—Ü—ñ—ó %s: –±–∞–ª–∞–Ω—Å=%.2f, —Ü—ñ–Ω–∞=%.2f, –∫—ñ–ª—å–∫—ñ—Å—Ç—å=%.6f",
            symbol,
            usdt_balance,
            price,
            amount,
        )
        return max(amount, 0.0)

    def _action_to_order(self, action: int) -> str:
        mapping = {0: "hold", 1: "buy", 2: "sell"}
        return mapping.get(action, "hold")

    def run(self, stop_event: threading.Event):
        self.bootstrap()
        logger.info("–°—Ç–∞—Ä—Ç —Ç–æ—Ä–≥–æ–≤–æ–≥–æ —Ü–∏–∫–ª—É")
        episode_rewards: List[float] = []
        while not stop_event.is_set():
            try:
                state, symbol, market_ctx = self.environment.get_state()
                current_band = self.supervisor.evaluate_market_noise(
                    vol_ratio=market_ctx["vol_ratio"],
                    book_pressure=market_ctx["book_pressure"],
                    trend_strength=market_ctx["trend_strength"],
                )
                action, value_estimate = self.agent.select_action(state)
                decision = self._action_to_order(action)

                reward = 0.0
                info: Dict[str, Any] = {"symbol": symbol, "decision": decision}

                if decision in {"buy", "sell"}:
                    amount = self._calculate_position(symbol, current_band)
                    if amount > 0:
                        order = self.executor.execute(symbol, decision, amount)
                        info["order"] = order
                        reward = self._evaluate_trade(symbol, decision, order)
                else:
                    info["note"] = "–ü—Ä–æ–ø—É—Å–∫ –¥—ñ—ó"

                self._record_experience(state, action, reward, value_estimate)
                episode_rewards.append(reward)

                logger.info("–ö—Ä–æ–∫ %s | %s | –≤–∏–Ω–∞–≥–æ—Ä–æ–¥–∞ %.5f", self.step_counter, info, reward)

                if len(self.replay_buffer) >= TRAIN_BATCH_SIZE:
                    self._train_from_buffer()
                    episode_rewards.clear()

                if self.step_counter % SAVE_MODEL_INTERVAL_STEPS == 0:
                    self._persist_model()

                self.step_counter += 1
                time.sleep(POLL_INTERVAL_SECONDS)
            except Exception as exc:  # noqa: BLE001
                logger.exception("–ù–µ–æ—á—ñ–∫—É–≤–∞–Ω–∞ –ø–æ–º–∏–ª–∫–∞ –≤ —Ç–æ—Ä–≥–æ–≤–æ–º—É —Ü–∏–∫–ª—ñ: %s", exc)
                time.sleep(POLL_INTERVAL_SECONDS)

    def _record_experience(self, state, action, reward, value_estimate):
        self.replay_buffer.append((state, action, reward, value_estimate))
        if len(self.replay_buffer) > 5 * TRAIN_BATCH_SIZE:
            self.replay_buffer.pop(0)

    def _train_from_buffer(self):
        states, actions, rewards, values = zip(*self.replay_buffer)
        states = np.stack(states)
        actions = np.array(actions)
        rewards = np.array(rewards, dtype=np.float32)
        values = np.array(values, dtype=np.float32)

        returns = np.zeros_like(rewards)
        running_return = 0.0
        for t in reversed(range(len(rewards))):
            running_return = rewards[t] + self.agent.gamma * running_return
            returns[t] = running_return

        advantages = returns - values
        loss = self.agent.train_batch(states, actions, advantages, returns)
        logger.info("–û–Ω–æ–≤–ª–µ–Ω–æ –∞–≥–µ–Ω—Ç (–≤—Ç—Ä–∞—Ç–∞ %.5f)", loss)
        self.replay_buffer.clear()

    def _persist_model(self):
        try:
            self.agent.save(MODEL_FILE_NAME)
            drive_id = self.cloud_manager.save_model(MODEL_FILE_NAME)
            logger.info("–ú–æ–¥–µ–ª—å –∑–±–µ—Ä–µ–∂–µ–Ω–æ. DriveID=%s", drive_id)
        except Exception as exc:  # noqa: BLE001
            logger.error("–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–±–µ—Ä–µ–≥—Ç–∏ –º–æ–¥–µ–ª—å: %s", exc)

    def _evaluate_trade(self, symbol: str, decision: str, order: Optional[Dict[str, Any]]) -> float:
        if not order:
            return -0.001  # –Ω–µ–≤–µ–ª–∏–∫–µ –ø–æ–∫–∞—Ä–∞–Ω–Ω—è
        fills = order.get("trades") or []
        pnl = sum(float(fill.get("fee", {}).get("cost", 0)) for fill in fills)
        pnl -= order.get("fee", {}).get("cost", 0)
        return float(pnl)


# ------------------------------------------------------------------------------
# Flask App & Background Thread
# ------------------------------------------------------------------------------


app = Flask(__name__)
exchange = build_exchange()
user_mode = os.getenv("TRADING_MODE", "BALANCED").upper()
if user_mode not in RiskBand.__members__:
    logger.warning("–ù–µ–∫–æ—Ä–µ–∫—Ç–Ω–∏–π TRADING_MODE=%s, –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ BALANCED", user_mode)
    user_mode = "BALANCED"

supervisor = Supervisor(RiskBand[user_mode])
data_fetcher = MarketDataFetcher(exchange, DEFAULT_SYMBOLS)
environment = TradingEnvironment(data_fetcher, DEFAULT_SYMBOLS)
executor = TradeExecutor(exchange, supervisor)
cloud_manager = CloudModelManager(CLIENT_SECRETS_FILE, TOKEN_FILE, MODEL_DRIVE_FILE_ID)
symbol_deposit = {symbol: float(os.getenv("DEPOSIT_USDT", "1000")) for symbol in DEFAULT_SYMBOLS}

stop_event = threading.Event()
agent_runner = TradingAgentRunner(supervisor, environment, executor, cloud_manager, symbol_deposit)


def start_background_thread():
    if not hasattr(start_background_thread, "thread") or not start_background_thread.thread.is_alive():  # type: ignore[attr-defined]
        start_background_thread.thread = threading.Thread(  # type: ignore[attr-defined]
            target=agent_runner.run,
            name="TradingAgentThread",
            args=(stop_event,),
            daemon=True,
        )
        start_background_thread.thread.start()  # type: ignore[attr-defined]
        logger.info("–§–æ–Ω–æ–≤–∏–π –∞–≥–µ–Ω—Ç –∑–∞–ø—É—â–µ–Ω–æ")


@app.route("/", methods=["GET"])
def healthcheck():
    start_background_thread()
    return jsonify({"status": "ok", "timestamp": datetime.now(timezone.utc).isoformat()})


@app.route("/supervisor", methods=["GET"])
def get_supervisor():
    return jsonify(
        {
            "user_mode": supervisor.user_selected.value,
            "current_band": supervisor.current_band.value,
            "max_position_fraction": supervisor.current_band.max_position_fraction,
        }
    )


@app.route("/config", methods=["POST"])
def update_config():
    payload = request.get_json(force=True, silent=True) or {}
    symbols = payload.get("symbols")
    if symbols and isinstance(symbols, list):
        environment.symbols = symbols
    poll_interval = payload.get("poll_interval_seconds")
    if poll_interval:
        global POLL_INTERVAL_SECONDS  # noqa: PLW0603
        POLL_INTERVAL_SECONDS = int(poll_interval)
    return jsonify({"updated": True, "symbols": environment.symbols, "poll": POLL_INTERVAL_SECONDS})


@app.route("/shutdown", methods=["POST"])
def shutdown_agent():
    stop_event.set()
    return jsonify({"status": "stopping"})


# ------------------------------------------------------------------------------
# Entrypoint
# ------------------------------------------------------------------------------


def create_app() -> Flask:
    return app


if __name__ == "__main__":
    start_background_thread()
    app.run(host="0.0.0.0", port=int(os.getenv("PORT", "8000")))
"""
Streamlit –≤–µ–±-—ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è —Å–∏—Å—Ç–µ–º–∏ –∞—Ä–±—ñ—Ç—Ä–∞–∂—É
"""

import streamlit as st
import asyncio
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import json

from config import Config
from main import TradingBot


class ArbitrageApp:
    """–ì–æ–ª–æ–≤–Ω–∏–π –∫–ª–∞—Å Streamlit –¥–æ–¥–∞—Ç–∫—É"""
    
    def __init__(self):
        self.config = Config()
        self.system = None
        self.setup_page()
    
    def setup_page(self):
        """–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Å—Ç–æ—Ä—ñ–Ω–∫–∏"""
        st.set_page_config(
            page_title="–°–∏—Å—Ç–µ–º–∞ –ê—Ä–±—ñ—Ç—Ä–∞–∂—É",
            page_icon="üí∞",
            layout="wide",
            initial_sidebar_state="expanded"
        )
        
        st.title("üöÄ –°–∏—Å—Ç–µ–º–∞ –ú—ñ–∂–±—ñ—Ä–∂–æ–≤–æ–≥–æ –ê—Ä–±—ñ—Ç—Ä–∞–∂—É")
        st.markdown("---")
    
    def run(self):
        """–ó–∞–ø—É—Å–∫ –¥–æ–¥–∞—Ç–∫—É"""
        # –ë–æ–∫–æ–≤–∞ –ø–∞–Ω–µ–ª—å
        self.render_sidebar()
        
        # –û—Å–Ω–æ–≤–Ω–∞ –ø–∞–Ω–µ–ª—å
        self.render_main_panel()
    
    def render_sidebar(self):
        """–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –±–æ–∫–æ–≤–æ—ó –ø–∞–Ω–µ–ª—ñ"""
        with st.sidebar:
            st.header("üéõÔ∏è –£–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è")
            
            # –°—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º–∏
            if self.system:
                status = self.system.get_status()
                if status['is_running']:
                    st.success("üü¢ –°–∏—Å—Ç–µ–º–∞ –∞–∫—Ç–∏–≤–Ω–∞")
                    st.info(f"–ê–∫—Ç–∏–≤–Ω–∏–π –º–æ–¥—É–ª—å: {status['active_module']}")
                else:
                    st.error("üî¥ –°–∏—Å—Ç–µ–º–∞ –∑—É–ø–∏–Ω–µ–Ω–∞")
            else:
                st.warning("‚ö†Ô∏è –°–∏—Å—Ç–µ–º–∞ –Ω–µ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–∞")
            
            st.markdown("---")
            
            # –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è
            col1, col2 = st.columns(2)
            
            with col1:
                if st.button("‚ñ∂Ô∏è –ó–∞–ø—É—Å—Ç–∏—Ç–∏", key="start_btn"):
                    self.start_system()
            
            with col2:
                if st.button("‚èπÔ∏è –ó—É–ø–∏–Ω–∏—Ç–∏", key="stop_btn"):
                    self.stop_system()
            
            st.markdown("---")
            
            # –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è
            st.header("‚öôÔ∏è –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è")
            
            # –£–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è —Ä–∏–∑–∏–∫–∞–º–∏
            st.subheader("üõ°Ô∏è –†–∏–∑–∏–∫–∏")
            max_position = st.number_input(
                "–ú–∞–∫—Å. —Ä–æ–∑–º—ñ—Ä –ø–æ–∑–∏—Ü—ñ—ó (USD)",
                min_value=100.0,
                max_value=10000.0,
                value=self.config.RISK.max_position_size,
                step=100.0
            )
            
            max_daily_loss = st.number_input(
                "–ú–∞–∫—Å. –¥–µ–Ω–Ω–∏–π –∑–±–∏—Ç–æ–∫ (USD)",
                min_value=10.0,
                max_value=1000.0,
                value=self.config.RISK.max_daily_loss,
                step=10.0
            )
            
            min_profit = st.number_input(
                "–ú—ñ–Ω. –ø—Ä–∏–±—É—Ç–æ–∫ (%)",
                min_value=0.01,
                max_value=5.0,
                value=self.config.RISK.min_profit_threshold,
                step=0.01
            )
            
            # –ö–æ–ø—ñ—Ç—Ä–µ–π–¥–∏–Ω–≥
            st.subheader("üìã –ö–æ–ø—ñ—Ç—Ä–µ–π–¥–∏–Ω–≥")
            copy_ratio = st.slider(
                "–ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è",
                min_value=0.1,
                max_value=2.0,
                value=self.config.COPY_TRADING.copy_ratio,
                step=0.1
            )
            
            min_copy_profit = st.number_input(
                "–ú—ñ–Ω. –ø—Ä–∏–±—É—Ç–æ–∫ –¥–ª—è –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è (%)",
                min_value=0.1,
                max_value=10.0,
                value=self.config.COPY_TRADING.min_profit_threshold,
                step=0.1
            )
    
    def render_main_panel(self):
        """–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –æ—Å–Ω–æ–≤–Ω–æ—ó –ø–∞–Ω–µ–ª—ñ"""
        # –í–∫–ª–∞–¥–∫–∏
        tab1, tab2, tab3, tab4, tab5 = st.tabs([
            "üìä –î–∞—à–±–æ—Ä–¥", 
            "üí∞ –ê—Ä–±—ñ—Ç—Ä–∞–∂", 
            "üìã –ö–æ–ø—ñ—Ç—Ä–µ–π–¥–∏–Ω–≥", 
            "üîç –°–∫–∞–Ω–µ—Ä —Ä–∏–Ω–∫—É", 
            "üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"
        ])
        
        with tab1:
            self.render_dashboard()
        
        with tab2:
            self.render_arbitrage_tab()
        
        with tab3:
            self.render_copy_trading_tab()
        
        with tab4:
            self.render_market_scanner_tab()
        
        with tab5:
            self.render_statistics_tab()
    
    def render_dashboard(self):
        """–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –¥–∞—à–±–æ—Ä–¥—É"""
        st.header("üìä –ó–∞–≥–∞–ª—å–Ω–∏–π –¥–∞—à–±–æ—Ä–¥")
        
        if not self.system:
            st.warning("‚ö†Ô∏è –°–∏—Å—Ç–µ–º–∞ –Ω–µ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–∞. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å '–ó–∞–ø—É—Å—Ç–∏—Ç–∏' –≤ –±–æ–∫–æ–≤—ñ–π –ø–∞–Ω–µ–ª—ñ.")
            return
        
        status = self.system.get_status()
        
        # –ú–µ—Ç—Ä–∏–∫–∏
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric(
                "–°—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º–∏",
                "üü¢ –ê–∫—Ç–∏–≤–Ω–∞" if status['is_running'] else "üî¥ –ó—É–ø–∏–Ω–µ–Ω–∞",
                delta=None
            )
        
        with col2:
            active_module = status.get('active_module', '–ù–µ–º–∞—î')
            st.metric(
                "–ê–∫—Ç–∏–≤–Ω–∏–π –º–æ–¥—É–ª—å",
                active_module,
                delta=None
            )
        
        with col3:
            # –ó–∞–≥–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            total_trades = sum(
                module_stats.get('stats', {}).get('successful_trades', 0) 
                for module_stats in status.get('modules_status', {}).values()
            )
            st.metric(
                "–í—Å—å–æ–≥–æ —É–≥–æ–¥",
                total_trades,
                delta=None
            )
        
        with col4:
            # –ó–∞–≥–∞–ª—å–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫
            total_profit = sum(
                module_stats.get('stats', {}).get('total_profit', 0) 
                for module_stats in status.get('modules_status', {}).values()
            )
            st.metric(
                "–ó–∞–≥–∞–ª—å–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫",
                f"${total_profit:.2f}",
                delta=None
            )
        
        st.markdown("---")
        
        # –°—Ç–∞—Ç—É—Å –º–æ–¥—É–ª—ñ–≤
        st.subheader("üîß –°—Ç–∞—Ç—É—Å –º–æ–¥—É–ª—ñ–≤")
        
        modules_data = []
        for module_name, module_status in status.get('modules_status', {}).items():
            modules_data.append({
                '–ú–æ–¥—É–ª—å': module_name,
                '–Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ': '‚úÖ' if module_status.get('is_initialized') else '‚ùå',
                '–ü—Ä–∞—Ü—é—î': '‚úÖ' if module_status.get('is_running') else '‚ùå',
                '–£–≥–æ–¥–∏': module_status.get('stats', {}).get('successful_trades', 0),
                '–ü—Ä–∏–±—É—Ç–æ–∫': f"${module_status.get('stats', {}).get('total_profit', 0):.2f}",
                '–û—Å—Ç–∞–Ω–Ω—î –æ–Ω–æ–≤–ª–µ–Ω–Ω—è': module_status.get('last_update', '–ù–µ–º–∞—î')
            })
        
        if modules_data:
            df_modules = pd.DataFrame(modules_data)
            st.dataframe(df_modules, use_container_width=True)
        else:
            st.info("üìù –ù–µ–º–∞—î –¥–∞–Ω–∏—Ö –ø—Ä–æ –º–æ–¥—É–ª—ñ")
    
    def render_arbitrage_tab(self):
        """–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –≤–∫–ª–∞–¥–∫–∏ –∞—Ä–±—ñ—Ç—Ä–∞–∂—É"""
        st.header("üí∞ –ú—ñ–∂–±—ñ—Ä–∂–æ–≤–∏–π –∞—Ä–±—ñ—Ç—Ä–∞–∂")
        
        if not self.system:
            st.warning("‚ö†Ô∏è –°–∏—Å—Ç–µ–º–∞ –Ω–µ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–∞")
            return
        
        # –ü–æ—Ç–æ—á–Ω—ñ –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ
        st.subheader("üéØ –ü–æ—Ç–æ—á–Ω—ñ –∞—Ä–±—ñ—Ç—Ä–∞–∂–Ω—ñ –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ")
        
        # Mock –¥–∞–Ω—ñ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü—ñ—ó
        opportunities_data = [
            {
                '–ü–∞—Ä–∞': 'BTC/USDT',
                '–ö—É–ø—ñ–≤–ª—è': 'Binance',
                '–ü—Ä–æ–¥–∞–∂': 'Bybit',
                '–¶—ñ–Ω–∞ –∫—É–ø—ñ–≤–ª—ñ': 50000.0,
                '–¶—ñ–Ω–∞ –ø—Ä–æ–¥–∞–∂—É': 50050.0,
                '–°–ø—Ä–µ–¥ (%)': 0.1,
                '–ß–∏—Å—Ç–∏–π –ø—Ä–∏–±—É—Ç–æ–∫ (%)': 0.08,
                '–û–±—Å—è–≥': 1000.0
            },
            {
                '–ü–∞—Ä–∞': 'ETH/USDT',
                '–ö—É–ø—ñ–≤–ª—è': 'KuCoin',
                '–ü—Ä–æ–¥–∞–∂': 'Binance',
                '–¶—ñ–Ω–∞ –∫—É–ø—ñ–≤–ª—ñ': 3000.0,
                '–¶—ñ–Ω–∞ –ø—Ä–æ–¥–∞–∂—É': 3005.0,
                '–°–ø—Ä–µ–¥ (%)': 0.17,
                '–ß–∏—Å—Ç–∏–π –ø—Ä–∏–±—É—Ç–æ–∫ (%)': 0.15,
                '–û–±—Å—è–≥': 500.0
            }
        ]
        
        df_opportunities = pd.DataFrame(opportunities_data)
        st.dataframe(df_opportunities, use_container_width=True)
        
        # –ì—Ä–∞—Ñ—ñ–∫ —Å–ø—Ä–µ–¥—ñ–≤
        st.subheader("üìà –ì—Ä–∞—Ñ—ñ–∫ —Å–ø—Ä–µ–¥—ñ–≤")
        
        fig = px.bar(
            df_opportunities, 
            x='–ü–∞—Ä–∞', 
            y='–°–ø—Ä–µ–¥ (%)',
            title='–ê—Ä–±—ñ—Ç—Ä–∞–∂–Ω—ñ —Å–ø—Ä–µ–¥–∏ –ø–æ –ø–∞—Ä–∞—Ö',
            color='–ß–∏—Å—Ç–∏–π –ø—Ä–∏–±—É—Ç–æ–∫ (%)',
            color_continuous_scale='RdYlGn'
        )
        st.plotly_chart(fig, use_container_width=True)
    
    def render_copy_trading_tab(self):
        """–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –≤–∫–ª–∞–¥–∫–∏ –∫–æ–ø—ñ—Ç—Ä–µ–π–¥–∏–Ω–≥—É"""
        st.header("üìã –ö–æ–ø—ñ—Ç—Ä–µ–π–¥–∏–Ω–≥ –∑ Traiex")
        
        if not self.system:
            st.warning("‚ö†Ô∏è –°–∏—Å—Ç–µ–º–∞ –Ω–µ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–∞")
            return
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞
        st.subheader("ü§ñ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞ Traiex")
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("–í—Å—å–æ–≥–æ —É–≥–æ–¥", "150", delta="+5")
        
        with col2:
            st.metric("–ü—Ä–∏–±—É—Ç–∫–æ–≤–∏—Ö —É–≥–æ–¥", "95", delta="+3")
        
        with col3:
            st.metric("Win Rate", "63.3%", delta="+2.1%")
        
        with col4:
            st.metric("–ó–∞–≥–∞–ª—å–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫", "$1,250.50", delta="+$45.20")
        
        # –û—Å—Ç–∞–Ω–Ω—ñ —Å–∫–æ–ø—ñ–π–æ–≤–∞–Ω—ñ —É–≥–æ–¥–∏
        st.subheader("üìã –û—Å—Ç–∞–Ω–Ω—ñ —Å–∫–æ–ø—ñ–π–æ–≤–∞–Ω—ñ —É–≥–æ–¥–∏")
        
        copied_trades_data = [
            {
                '–ß–∞—Å': '2024-01-15 14:30:25',
                '–ü–∞—Ä–∞': 'BTC/USDT',
                '–°—Ç–æ—Ä–æ–Ω–∞': '–ö—É–ø—ñ–≤–ª—è',
                '–û–±—Å—è–≥': 0.1,
                '–¶—ñ–Ω–∞': 50000.0,
                '–ë—ñ—Ä–∂–∞': 'Binance',
                '–°—Ç–∞—Ç—É—Å': '–í–∏–∫–æ–Ω–∞–Ω–æ'
            },
            {
                '–ß–∞—Å': '2024-01-15 14:25:10',
                '–ü–∞—Ä–∞': 'ETH/USDT',
                '–°—Ç–æ—Ä–æ–Ω–∞': '–ü—Ä–æ–¥–∞–∂',
                '–û–±—Å—è–≥': 1.0,
                '–¶—ñ–Ω–∞': 3000.0,
                '–ë—ñ—Ä–∂–∞': 'Bybit',
                '–°—Ç–∞—Ç—É—Å': '–í–∏–∫–æ–Ω–∞–Ω–æ'
            }
        ]
        
        df_copied = pd.DataFrame(copied_trades_data)
        st.dataframe(df_copied, use_container_width=True)
    
    def render_market_scanner_tab(self):
        """–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –≤–∫–ª–∞–¥–∫–∏ —Å–∫–∞–Ω–µ—Ä–∞ —Ä–∏–Ω–∫—É"""
        st.header("üîç –°–∫–∞–Ω–µ—Ä —Ä–∏–Ω–∫—É")
        
        if not self.system:
            st.warning("‚ö†Ô∏è –°–∏—Å—Ç–µ–º–∞ –Ω–µ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–∞")
            return
        
        # –¢–æ–ø —Ç–æ—Ä–≥–æ–≤—ñ –ø–∞—Ä–∏
        st.subheader("üèÜ –¢–æ–ø —Ç–æ—Ä–≥–æ–≤—ñ –ø–∞—Ä–∏")
        
        top_pairs_data = [
            {'–†–∞–Ω–≥': 1, '–ü–∞—Ä–∞': 'BTC/USDT', '–†–µ–π—Ç–∏–Ω–≥': 8.5, '–õ—ñ–∫–≤—ñ–¥–Ω—ñ—Å—Ç—å': 9.2, '–°–ø—Ä–µ–¥ (%)': 0.15},
            {'–†–∞–Ω–≥': 2, '–ü–∞—Ä–∞': 'ETH/USDT', '–†–µ–π—Ç–∏–Ω–≥': 7.8, '–õ—ñ–∫–≤—ñ–¥–Ω—ñ—Å—Ç—å': 8.5, '–°–ø—Ä–µ–¥ (%)': 0.12},
            {'–†–∞–Ω–≥': 3, '–ü–∞—Ä–∞': 'BNB/USDT', '–†–µ–π—Ç–∏–Ω–≥': 7.2, '–õ—ñ–∫–≤—ñ–¥–Ω—ñ—Å—Ç—å': 7.8, '–°–ø—Ä–µ–¥ (%)': 0.18},
            {'–†–∞–Ω–≥': 4, '–ü–∞—Ä–∞': 'ADA/USDT', '–†–µ–π—Ç–∏–Ω–≥': 6.9, '–õ—ñ–∫–≤—ñ–¥–Ω—ñ—Å—Ç—å': 6.5, '–°–ø—Ä–µ–¥ (%)': 0.25},
            {'–†–∞–Ω–≥': 5, '–ü–∞—Ä–∞': 'SOL/USDT', '–†–µ–π—Ç–∏–Ω–≥': 6.5, '–õ—ñ–∫–≤—ñ–¥–Ω—ñ—Å—Ç—å': 7.1, '–°–ø—Ä–µ–¥ (%)': 0.22}
        ]
        
        df_top_pairs = pd.DataFrame(top_pairs_data)
        st.dataframe(df_top_pairs, use_container_width=True)
        
        # –ì—Ä–∞—Ñ—ñ–∫ —Ä–µ–π—Ç–∏–Ω–≥—ñ–≤
        st.subheader("üìä –ì—Ä–∞—Ñ—ñ–∫ —Ä–µ–π—Ç–∏–Ω–≥—ñ–≤")
        
        fig = px.scatter(
            df_top_pairs,
            x='–õ—ñ–∫–≤—ñ–¥–Ω—ñ—Å—Ç—å',
            y='–°–ø—Ä–µ–¥ (%)',
            size='–†–µ–π—Ç–∏–Ω–≥',
            color='–†–µ–π—Ç–∏–Ω–≥',
            hover_name='–ü–∞—Ä–∞',
            title='–†–µ–π—Ç–∏–Ω–≥ —Ç–æ—Ä–≥–æ–≤–∏—Ö –ø–∞—Ä',
            color_continuous_scale='RdYlGn'
        )
        st.plotly_chart(fig, use_container_width=True)
    
    def render_statistics_tab(self):
        """–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –≤–∫–ª–∞–¥–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
        st.header("üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")
        
        if not self.system:
            st.warning("‚ö†Ô∏è –°–∏—Å—Ç–µ–º–∞ –Ω–µ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–∞")
            return
        
        # –ó–∞–≥–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        st.subheader("üìä –ó–∞–≥–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")
        
        col1, col2 = st.columns(2)
        
        with col1:
            # –ì—Ä–∞—Ñ—ñ–∫ –ø—Ä–∏–±—É—Ç–∫—É –ø–æ –¥–Ω—è—Ö
            dates = pd.date_range(start='2024-01-01', end='2024-01-15', freq='D')
            profits = [25.50, 45.20, 32.10, 67.80, 23.45, 89.30, 56.70, 34.20, 78.90, 45.60, 67.30, 23.80, 56.40, 89.70, 34.50]
            
            fig_profit = px.line(
                x=dates, 
                y=profits,
                title='–ü—Ä–∏–±—É—Ç–æ–∫ –ø–æ –¥–Ω—è—Ö',
                labels={'x': '–î–∞—Ç–∞', 'y': '–ü—Ä–∏–±—É—Ç–æ–∫ (USD)'}
            )
            st.plotly_chart(fig_profit, use_container_width=True)
        
        with col2:
            # –†–æ–∑–ø–æ–¥—ñ–ª —É–≥–æ–¥ –ø–æ –º–æ–¥—É–ª—è—Ö
            modules = ['–ê—Ä–±—ñ—Ç—Ä–∞–∂', '–ö–æ–ø—ñ—Ç—Ä–µ–π–¥–∏–Ω–≥', '–°–∫–∞–Ω–µ—Ä']
            trades_count = [45, 78, 12]
            
            fig_dist = px.pie(
                values=trades_count,
                names=modules,
                title='–†–æ–∑–ø–æ–¥—ñ–ª —É–≥–æ–¥ –ø–æ –º–æ–¥—É–ª—è—Ö'
            )
            st.plotly_chart(fig_dist, use_container_width=True)
        
        # –î–µ—Ç–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        st.subheader("üìã –î–µ—Ç–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")
        
        stats_data = [
            {'–ú–µ—Ç—Ä–∏–∫–∞': '–í—Å—å–æ–≥–æ —É–≥–æ–¥', '–ó–Ω–∞—á–µ–Ω–Ω—è': '135', '–ó–º—ñ–Ω–∞': '+12'},
            {'–ú–µ—Ç—Ä–∏–∫–∞': '–£—Å–ø—ñ—à–Ω–∏—Ö —É–≥–æ–¥', '–ó–Ω–∞—á–µ–Ω–Ω—è': '98', '–ó–º—ñ–Ω–∞': '+8'},
            {'–ú–µ—Ç—Ä–∏–∫–∞': 'Win Rate', '–ó–Ω–∞—á–µ–Ω–Ω—è': '72.6%', '–ó–º—ñ–Ω–∞': '+3.2%'},
            {'–ú–µ—Ç—Ä–∏–∫–∞': '–ó–∞–≥–∞–ª—å–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫', '–ó–Ω–∞—á–µ–Ω–Ω—è': '$1,234.50', '–ó–º—ñ–Ω–∞': '+$156.80'},
            {'–ú–µ—Ç—Ä–∏–∫–∞': '–°–µ—Ä–µ–¥–Ω—ñ–π –ø—Ä–∏–±—É—Ç–æ–∫', '–ó–Ω–∞—á–µ–Ω–Ω—è': '$9.14', '–ó–º—ñ–Ω–∞': '+$1.23'},
            {'–ú–µ—Ç—Ä–∏–∫–∞': '–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫', '–ó–Ω–∞—á–µ–Ω–Ω—è': '$89.30', '–ó–º—ñ–Ω–∞': '–ù–æ–≤–∏–π —Ä–µ–∫–æ—Ä–¥'},
            {'–ú–µ—Ç—Ä–∏–∫–∞': '–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∏–π –∑–±–∏—Ç–æ–∫', '–ó–Ω–∞—á–µ–Ω–Ω—è': '$12.50', '–ó–º—ñ–Ω–∞': '-$2.10'}
        ]
        
        df_stats = pd.DataFrame(stats_data)
        st.dataframe(df_stats, use_container_width=True)
    
    def start_system(self):
        """–ó–∞–ø—É—Å–∫ —Å–∏—Å—Ç–µ–º–∏"""
        try:
            if not self.system:
                self.system = TradingBot()
            
            # –ó–∞–ø—É—Å–∫ –≤ –æ–∫—Ä–µ–º–æ–º—É –ø–æ—Ç–æ—Ü—ñ
            asyncio.create_task(self.system.start())
            st.success("‚úÖ –°–∏—Å—Ç–µ–º–∞ –∑–∞–ø—É—â–µ–Ω–∞!")
            st.rerun()
            
        except Exception as e:
            st.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–∞–ø—É—Å–∫—É —Å–∏—Å—Ç–µ–º–∏: {e}")
    
    def stop_system(self):
        """–ó—É–ø–∏–Ω–∫–∞ —Å–∏—Å—Ç–µ–º–∏"""
        try:
            if self.system:
                asyncio.create_task(self.system.stop())
                st.success("‚úÖ –°–∏—Å—Ç–µ–º–∞ –∑—É–ø–∏–Ω–µ–Ω–∞!")
                st.rerun()
            else:
                st.warning("‚ö†Ô∏è –°–∏—Å—Ç–µ–º–∞ –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞")
                
        except Exception as e:
            st.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –∑—É–ø–∏–Ω–∫–∏ —Å–∏—Å—Ç–µ–º–∏: {e}")


def main():
    """–ì–æ–ª–æ–≤–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è"""
    app = ArbitrageApp()
    app.run()


if __name__ == "__main__":
    main()

```

```python
import logging
import os
import threading
import time
from dataclasses import dataclass
from datetime import datetime, timezone
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import ccxt
import numpy as np
import pandas as pd
import tensorflow as tf
from flask import Flask, jsonify, request
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from google.auth.transport.requests import Request as GoogleAuthRequest
import googleapiclient.http


# ------------------------------------------------------------------------------
# Configuration & Logging
# ------------------------------------------------------------------------------

logging.basicConfig(
    level=os.getenv("LOG_LEVEL", "INFO"),
    format="%(asctime)s [%(levelname)s] %(threadName)s %(message)s",
)
logger = logging.getLogger(__name__)

MODEL_FILE_NAME = os.getenv("MODEL_FILE_NAME", "agent_model.keras")
MODEL_DRIVE_FILE_ID = os.getenv("MODEL_DRIVE_FILE_ID")
CLIENT_SECRETS_FILE = os.getenv("CLIENT_SECRETS_FILE", "client_secrets.json")
TOKEN_FILE = os.getenv("GOOGLE_TOKEN_FILE", "token.json")
DRIVE_SCOPES = ["https://www.googleapis.com/auth/drive.file"]

CCXT_API_KEY = os.getenv("BINANCE_TESTNET_API_KEY")
CCXT_SECRET_KEY = os.getenv("BINANCE_TESTNET_SECRET_KEY")

DEFAULT_SYMBOLS = ["BTC/USDT", "ETH/USDT"]
POLL_INTERVAL_SECONDS = int(os.getenv("POLL_INTERVAL_SECONDS", "60"))
SAVE_MODEL_INTERVAL_STEPS = int(os.getenv("SAVE_MODEL_INTERVAL_STEPS", "30"))
TRAIN_BATCH_SIZE = int(os.getenv("TRAIN_BATCH_SIZE", "32"))
MAX_EPISODE_LENGTH = int(os.getenv("MAX_EPISODE_LENGTH", "96"))  # roughly 96 minutes


# ------------------------------------------------------------------------------
# Risk Management
# ------------------------------------------------------------------------------


class RiskBand(Enum):
    CONSERVATIVE = "CONSERVATIVE"
    BALANCED_CONSERVATIVE = "BALANCED_CONSERVATIVE"
    BALANCED = "BALANCED"
    BALANCED_AGGRESSIVE = "BALANCED_AGGRESSIVE"
    AGGRESSIVE = "AGGRESSIVE"

    @property
    def max_position_fraction(self) -> float:
        mapping = {
            RiskBand.CONSERVATIVE: 0.10,
            RiskBand.BALANCED_CONSERVATIVE: 0.15,
            RiskBand.BALANCED: 0.20,
            RiskBand.BALANCED_AGGRESSIVE: 0.25,
            RiskBand.AGGRESSIVE: 0.30,
        }
        return mapping[self]


RISK_DOWNGRADE_PATHS: Dict[RiskBand, List[RiskBand]] = {
    RiskBand.CONSERVATIVE: [RiskBand.CONSERVATIVE],
    RiskBand.BALANCED: [
        RiskBand.BALANCED,
        RiskBand.BALANCED_CONSERVATIVE,
        RiskBand.CONSERVATIVE,
    ],
    RiskBand.AGGRESSIVE: [
        RiskBand.AGGRESSIVE,
        RiskBand.BALANCED_AGGRESSIVE,
        RiskBand.BALANCED,
        RiskBand.BALANCED_CONSERVATIVE,
        RiskBand.CONSERVATIVE,
    ],
}


class Supervisor:
    """AI supervisor that enforces multi-level risk governance."""

    def __init__(self, user_selected: RiskBand):
        self.user_selected = user_selected
        self.current_band = user_selected

    def evaluate_market_noise(
        self,
        vol_ratio: float,
        book_pressure: float,
        trend_strength: float,
    ) -> RiskBand:
        """
        Decide on a safer risk band depending on market conditions.
        Higher volatility or imbalanced books => lower risk.
        """
        candidates = RISK_DOWNGRADE_PATHS[self.user_selected]
        score = (vol_ratio * 0.5) + (abs(book_pressure) * 0.3) - (abs(trend_strength) * 0.2)
        logger.debug("Supervisor noise score %.4f", score)

        if score > 1.5 and len(candidates) > 1:
            self.current_band = candidates[-1]
        elif score > 1.0 and len(candidates) > 2:
            self.current_band = candidates[-2]
        elif score > 0.7 and len(candidates) > 3:
            self.current_band = candidates[-3]
        else:
            self.current_band = candidates[0]

        logger.info("Supervisor risk band -> %s", self.current_band.value)
        return self.current_band


# ------------------------------------------------------------------------------
# Google Drive Persistence
# ------------------------------------------------------------------------------


class CloudModelManager:
    def __init__(
        self,
        client_secrets_path: str,
        token_path: str,
        drive_file_id: Optional[str],
    ) -> None:
        self.client_secrets_path = client_secrets_path
        self.token_path = token_path
        self.drive_file_id = drive_file_id
        self._service = None

    def _get_credentials(self) -> Credentials:
        if not Path(self.client_secrets_path).exists():
            raise FileNotFoundError(
                f"client_secrets.json –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –∑–∞ —à–ª—è—Ö–æ–º {self.client_secrets_path}"
            )

        creds: Optional[Credentials] = None
        token_file = Path(self.token_path)
        if token_file.exists():
            creds = Credentials.from_authorized_user_file(self.token_path, DRIVE_SCOPES)

        if not creds or not creds.valid:
            if creds and creds.expired and creds.refresh_token:
                logger.info("–û–Ω–æ–≤–ª–µ–Ω–Ω—è Google Drive —Ç–æ–∫–µ–Ω–∞")
                creds.refresh(GoogleAuthRequest())
            else:
                from google_auth_oauthlib.flow import InstalledAppFlow

                flow = InstalledAppFlow.from_client_secrets_file(
                    self.client_secrets_path,
                    DRIVE_SCOPES,
                )
                logger.info("–ó–∞–ø—É—Å–∫ OAuth-—Ñ–ª–æ—É –¥–ª—è Google Drive")
                creds = flow.run_console()
            token_file.write_text(creds.to_json(), encoding="utf-8")

        return creds

    def _get_service(self):
        if self._service is None:
            creds = self._get_credentials()
            self._service = build("drive", "v3", credentials=creds, cache_discovery=False)
        return self._service

    def load_model(self, local_path: str) -> bool:
        if not self.drive_file_id:
            logger.warning("MODEL_DRIVE_FILE_ID –Ω–µ –∑–∞–¥–∞–Ω–∏–π; –ø—Ä–æ–ø—É—Å–∫–∞—é –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –º–æ–¥–µ–ª—ñ")
            return False

        service = self._get_service()
        try:
            logger.info("–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –º–æ–¥–µ–ª—ñ –∑ Google Drive (%s)", self.drive_file_id)
            request = service.files().get_media(fileId=self.drive_file_id)
            fh = tf.io.gfile.GFile(local_path, "wb")
            downloader = googleapiclient.http.MediaIoBaseDownload(fh, request)
            done = False
            while not done:
                status, done = downloader.next_chunk()
                if status:
                    logger.debug("–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ %.2f%%", status.progress() * 100)
            fh.close()
            return True
        except HttpError as exc:
            logger.error("–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –º–æ–¥–µ–ª—å: %s", exc)
            return False

    def save_model(self, local_path: str) -> Optional[str]:
        service = self._get_service()
        if not Path(local_path).exists():
            logger.warning("–ù–µ–º–∞—î —Ñ–∞–π–ª—É –º–æ–¥–µ–ª—ñ %s –¥–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è", local_path)
            return self.drive_file_id

        metadata = {
            "name": MODEL_FILE_NAME,
            "mimeType": "application/octet-stream",
        }
        media = googleapiclient.http.MediaFileUpload(local_path, resumable=True)

        try:
            if self.drive_file_id:
                logger.info("–û–Ω–æ–≤–ª–µ–Ω–Ω—è –º–æ–¥–µ–ª—ñ –Ω–∞ Google Drive (%s)", self.drive_file_id)
                updated = (
                    service.files()
                    .update(fileId=self.drive_file_id, media_body=media, body=metadata)
                    .execute()
                )
            else:
                logger.info("–°—Ç–≤–æ—Ä–µ–Ω–Ω—è –Ω–æ–≤–æ–≥–æ —Ñ–∞–π–ª—É –º–æ–¥–µ–ª—ñ –Ω–∞ Google Drive")
                updated = service.files().create(media_body=media, body=metadata).execute()

            self.drive_file_id = updated.get("id")
            os.environ["MODEL_DRIVE_FILE_ID"] = self.drive_file_id
            return self.drive_file_id
        except HttpError as exc:
            logger.error("–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–±–µ—Ä–µ–≥—Ç–∏ –º–æ–¥–µ–ª—å –Ω–∞ Google Drive: %s", exc)
            return None


# ------------------------------------------------------------------------------
# Market Data & Execution
# ------------------------------------------------------------------------------


def build_exchange() -> ccxt.Exchange:
    exchange = ccxt.binance(
        {
            "enableRateLimit": True,
            "apiKey": CCXT_API_KEY,
            "secret": CCXT_SECRET_KEY,
            "timeout": 30000,
            "options": {"defaultType": "spot"},
        }
    )
    exchange.set_sandbox_mode(True)
    return exchange


class MarketDataFetcher:
    def __init__(self, exchange: ccxt.Exchange, symbols: List[str]):
        self.exchange = exchange
        self.symbols = symbols

    def get_recent_ohlcv(self, symbol: str, since_ms: Optional[int] = None) -> pd.DataFrame:
        ohlcv = self.exchange.fetch_ohlcv(symbol, timeframe="1m", since=since_ms, limit=200)
        df = pd.DataFrame(
            ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"]
        )
        df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms", utc=True)
        return df

    def get_ta_features(self, df: pd.DataFrame) -> Dict[str, float]:
        if df.empty:
            return {"rsi": 50.0, "ma_fast": 0.0, "ma_slow": 0.0, "volatility": 0.0}

        close = df["close"]
        delta = close.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rs = gain / (loss + 1e-9)
        rsi = 100 - (100 / (1 + rs.iloc[-1]))

        ma_fast = close.rolling(window=10).mean().iloc[-1]
        ma_slow = close.rolling(window=30).mean().iloc[-1]
        volatility = close.pct_change().rolling(window=30).std().iloc[-1]

        return {
            "rsi": float(np.nan_to_num(rsi, nan=50.0)),
            "ma_fast": float(np.nan_to_num(ma_fast, nan=close.iloc[-1])),
            "ma_slow": float(np.nan_to_num(ma_slow, nan=close.iloc[-1])),
            "volatility": float(np.nan_to_num(volatility, nan=0.0)),
        }

    def get_order_book_metrics(self, symbol: str) -> Dict[str, float]:
        order_book = self.exchange.fetch_order_book(symbol)
        bids = np.array(order_book["bids"][:20])
        asks = np.array(order_book["asks"][:20])
        bid_volume = bids[:, 1].sum() if bids.size else 0.0
        ask_volume = asks[:, 1].sum() if asks.size else 0.0
        imbalance = (bid_volume - ask_volume) / (bid_volume + ask_volume + 1e-9)
        return {
            "bid_volume": float(bid_volume),
            "ask_volume": float(ask_volume),
            "imbalance": float(imbalance),
        }


class TradeExecutor:
    def __init__(self, exchange: ccxt.Exchange, supervisor: Supervisor):
        self.exchange = exchange
        self.supervisor = supervisor

    def get_balance(self, asset: str) -> float:
        balance = self.exchange.fetch_balance()
        return float(balance.get(asset, {}).get("free", 0.0))

    def execute(self, symbol: str, side: str, amount: float) -> Optional[Dict[str, Any]]:
        try:
            logger.info("–í–∏–∫–æ–Ω–∞–Ω–Ω—è –æ—Ä–¥–µ—Ä—É %s %s %.6f", symbol, side, amount)
            if amount <= 0:
                return None
            order = self.exchange.create_market_order(symbol, side.lower(), amount)
            return order
        except Exception as exc:  # noqa: BLE001
            logger.error("–ü–æ–º–∏–ª–∫–∞ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –æ—Ä–¥–µ—Ä—É: %s", exc)
            return None

    def max_position_size(self, usdt_balance: float) -> float:
        allowed_fraction = self.supervisor.current_band.max_position_fraction
        return usdt_balance * allowed_fraction


# ------------------------------------------------------------------------------
# Reinforcement Learning Agent
# ------------------------------------------------------------------------------


class TradingEnvironment:
    def __init__(self, data_fetcher: MarketDataFetcher, symbols: List[str]):
        self.data_fetcher = data_fetcher
        self.symbols = symbols
        self.last_prices: Dict[str, float] = {s: 0.0 for s in symbols}

    def get_state(self) -> Tuple[np.ndarray, str]:
        symbol = self._select_symbol()
        df = self.data_fetcher.get_recent_ohlcv(symbol)
        ta = self.data_fetcher.get_ta_features(df)
        book = self.data_fetcher.get_order_book_metrics(symbol)
        latest_price = df["close"].iloc[-1] if not df.empty else self.last_prices[symbol]
        self.last_prices[symbol] = latest_price

        state_vector = np.array(
            [
                ta["rsi"] / 100.0,
                (ta["ma_fast"] - ta["ma_slow"]) / (latest_price + 1e-9),
                ta["volatility"],
                book["imbalance"],
            ],
            dtype=np.float32,
        )
        market_context = {
            "vol_ratio": max(ta["volatility"], 1e-6) * 100,
            "book_pressure": book["imbalance"],
            "trend_strength": ta["ma_fast"] - ta["ma_slow"],
        }
        return state_vector, symbol, market_context

    def _select_symbol(self) -> str:
        weights = []
        for symbol in self.symbols:
            df = self.data_fetcher.get_recent_ohlcv(symbol)
            if df.empty:
                weights.append(1.0)
            else:
                weights.append(df["volume"].iloc[-30:].mean())
        total = sum(weights)
        weights = [w / total if total else 1 / len(self.symbols) for w in weights]
        return np.random.choice(self.symbols, p=weights)


class ActorCriticAgent:
    def __init__(self, state_dim: int, action_dim: int, learning_rate: float = 1e-4):
        self.state_dim = state_dim
        self.action_dim = action_dim
        self.gamma = 0.99
        self.learning_rate = learning_rate
        self.model = self._build_model()
        self.optimizer = tf.keras.optimizers.Adam(learning_rate=self.learning_rate)

    def _build_model(self) -> tf.keras.Model:
        inputs = tf.keras.Input(shape=(self.state_dim,))
        dense1 = tf.keras.layers.Dense(64, activation="relu")(inputs)
        dense2 = tf.keras.layers.Dense(64, activation="relu")(dense1)
        policy_logits = tf.keras.layers.Dense(self.action_dim, activation="linear")(dense2)
        value = tf.keras.layers.Dense(1, activation="linear")(dense2)
        model = tf.keras.Model(inputs=inputs, outputs=[policy_logits, value])
        model.compile()
        return model

    def select_action(self, state: np.ndarray) -> Tuple[int, float]:
        state = np.expand_dims(state, axis=0)
        logits, value = self.model(state, training=False)
        logits = logits.numpy()[0]
        probs = tf.nn.softmax(logits).numpy()
        action = np.random.choice(self.action_dim, p=probs)
        return int(action), float(value.numpy()[0][0])

    def train_batch(
        self,
        states: np.ndarray,
        actions: np.ndarray,
        advantages: np.ndarray,
        returns: np.ndarray,
    ) -> float:
        with tf.GradientTape() as tape:
            logits, values = self.model(states, training=True)
            values = tf.squeeze(values, axis=1)
            value_loss = tf.reduce_mean(tf.square(returns - values))
            policy = tf.nn.log_softmax(logits)
            indices = tf.stack([tf.range(tf.shape(actions)[0]), actions], axis=1)
            picked_log_probs = tf.gather_nd(policy, indices)
            policy_loss = -tf.reduce_mean(picked_log_probs * advantages)
            entropy = -tf.reduce_mean(tf.exp(policy) * policy)
            loss = policy_loss + 0.5 * value_loss - 0.01 * entropy

        grads = tape.gradient(loss, self.model.trainable_variables)
        self.optimizer.apply_gradients(zip(grads, self.model.trainable_variables))
        return float(loss.numpy())

    def save(self, path: str) -> None:
        self.model.save(path)

    def load(self, path: str) -> None:
        if Path(path).exists():
            self.model = tf.keras.models.load_model(path)
            logger.info("–ú–æ–¥–µ–ª—å –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ –∑ %s", path)
        else:
            logger.warning("–§–∞–π–ª –º–æ–¥–µ–ª—ñ %s –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é –ø–µ—Ä–≤—ñ—Å–Ω—É –º–æ–¥–µ–ª—å", path)


# ------------------------------------------------------------------------------
# Trading Orchestrator
# ------------------------------------------------------------------------------


class TradingAgentRunner:
    def __init__(
        self,
        supervisor: Supervisor,
        environment: TradingEnvironment,
        executor: TradeExecutor,
        cloud_manager: CloudModelManager,
        symbol_deposit: Dict[str, float],
    ):
        self.supervisor = supervisor
        self.environment = environment
        self.executor = executor
        self.cloud_manager = cloud_manager
        self.symbol_deposit = symbol_deposit
        self.agent = ActorCriticAgent(state_dim=4, action_dim=3)
        self.replay_buffer: List[Tuple[np.ndarray, int, float, float]] = []
        self.step_counter = 0

    def bootstrap(self):
        try:
            if self.cloud_manager.load_model(MODEL_FILE_NAME):
                self.agent.load(MODEL_FILE_NAME)
            else:
                logger.info("–ó–∞–ø—É—Å–∫–∞—é –∞–≥–µ–Ω—Ç–∞ –∑ –≤–∏–ø–∞–¥–∫–æ–≤–∏–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏")
        except Exception as exc:  # noqa: BLE001
            logger.error("–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –º–æ–¥–µ–ª—å: %s", exc)

    def _calculate_position(self, symbol: str, risk_band: RiskBand) -> float:
        base, quote = symbol.split("/")
        usdt_balance = self.executor.get_balance(quote)
        max_position = self.executor.max_position_size(usdt_balance)
        price = self.environment.last_prices.get(symbol) or self.executor.exchange.fetch_ticker(
            symbol
        )["last"]
        amount = max_position / price
        logger.debug(
            "–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –ø–æ–∑–∏—Ü—ñ—ó %s: –±–∞–ª–∞–Ω—Å=%.2f, —Ü—ñ–Ω–∞=%.2f, –∫—ñ–ª—å–∫—ñ—Å—Ç—å=%.6f",
            symbol,
            usdt_balance,
            price,
            amount,
        )
        return max(amount, 0.0)

    def _action_to_order(self, action: int) -> str:
        mapping = {0: "hold", 1: "buy", 2: "sell"}
        return mapping.get(action, "hold")

    def run(self, stop_event: threading.Event):
        self.bootstrap()
        logger.info("–°—Ç–∞—Ä—Ç —Ç–æ—Ä–≥–æ–≤–æ–≥–æ —Ü–∏–∫–ª—É")
        episode_rewards: List[float] = []
        while not stop_event.is_set():
            try:
                state, symbol, market_ctx = self.environment.get_state()
                current_band = self.supervisor.evaluate_market_noise(
                    vol_ratio=market_ctx["vol_ratio"],
                    book_pressure=market_ctx["book_pressure"],
                    trend_strength=market_ctx["trend_strength"],
                )
                action, value_estimate = self.agent.select_action(state)
                decision = self._action_to_order(action)

                reward = 0.0
                info: Dict[str, Any] = {"symbol": symbol, "decision": decision}

                if decision in {"buy", "sell"}:
                    amount = self._calculate_position(symbol, current_band)
                    if amount > 0:
                        order = self.executor.execute(symbol, decision, amount)
                        info["order"] = order
                        reward = self._evaluate_trade(symbol, decision, order)
                else:
                    info["note"] = "–ü—Ä–æ–ø—É—Å–∫ –¥—ñ—ó"

                self._record_experience(state, action, reward, value_estimate)
                episode_rewards.append(reward)

                logger.info("–ö—Ä–æ–∫ %s | %s | –≤–∏–Ω–∞–≥–æ—Ä–æ–¥–∞ %.5f", self.step_counter, info, reward)

                if len(self.replay_buffer) >= TRAIN_BATCH_SIZE:
                    self._train_from_buffer()
                    episode_rewards.clear()

                if self.step_counter % SAVE_MODEL_INTERVAL_STEPS == 0:
                    self._persist_model()

                self.step_counter += 1
                time.sleep(POLL_INTERVAL_SECONDS)
            except Exception as exc:  # noqa: BLE001
                logger.exception("–ù–µ–æ—á—ñ–∫—É–≤–∞–Ω–∞ –ø–æ–º–∏–ª–∫–∞ –≤ —Ç–æ—Ä–≥–æ–≤–æ–º—É —Ü–∏–∫–ª—ñ: %s", exc)
                time.sleep(POLL_INTERVAL_SECONDS)

    def _record_experience(self, state, action, reward, value_estimate):
        self.replay_buffer.append((state, action, reward, value_estimate))
        if len(self.replay_buffer) > 5 * TRAIN_BATCH_SIZE:
            self.replay_buffer.pop(0)

    def _train_from_buffer(self):
        states, actions, rewards, values = zip(*self.replay_buffer)
        states = np.stack(states)
        actions = np.array(actions)
        rewards = np.array(rewards, dtype=np.float32)
        values = np.array(values, dtype=np.float32)

        returns = np.zeros_like(rewards)
        running_return = 0.0
        for t in reversed(range(len(rewards))):
            running_return = rewards[t] + self.agent.gamma * running_return
            returns[t] = running_return

        advantages = returns - values
        loss = self.agent.train_batch(states, actions, advantages, returns)
        logger.info("–û–Ω–æ–≤–ª–µ–Ω–æ –∞–≥–µ–Ω—Ç (–≤—Ç—Ä–∞—Ç–∞ %.5f)", loss)
        self.replay_buffer.clear()

    def _persist_model(self):
        try:
            self.agent.save(MODEL_FILE_NAME)
            drive_id = self.cloud_manager.save_model(MODEL_FILE_NAME)
            logger.info("–ú–æ–¥–µ–ª—å –∑–±–µ—Ä–µ–∂–µ–Ω–æ. DriveID=%s", drive_id)
        except Exception as exc:  # noqa: BLE001
            logger.error("–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–±–µ—Ä–µ–≥—Ç–∏ –º–æ–¥–µ–ª—å: %s", exc)

    def _evaluate_trade(self, symbol: str, decision: str, order: Optional[Dict[str, Any]]) -> float:
        if not order:
            return -0.001  # –Ω–µ–≤–µ–ª–∏–∫–µ –ø–æ–∫–∞—Ä–∞–Ω–Ω—è
        fills = order.get("trades") or []
        pnl = sum(float(fill.get("fee", {}).get("cost", 0)) for fill in fills)
        pnl -= order.get("fee", {}).get("cost", 0)
        return float(pnl)


# ------------------------------------------------------------------------------
# Flask App & Background Thread
# ------------------------------------------------------------------------------


app = Flask(__name__)
exchange = build_exchange()
user_mode = os.getenv("TRADING_MODE", "BALANCED").upper()
if user_mode not in RiskBand.__members__:
    logger.warning("–ù–µ–∫–æ—Ä–µ–∫—Ç–Ω–∏–π TRADING_MODE=%s, –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ BALANCED", user_mode)
    user_mode = "BALANCED"

supervisor = Supervisor(RiskBand[user_mode])
data_fetcher = MarketDataFetcher(exchange, DEFAULT_SYMBOLS)
environment = TradingEnvironment(data_fetcher, DEFAULT_SYMBOLS)
executor = TradeExecutor(exchange, supervisor)
cloud_manager = CloudModelManager(CLIENT_SECRETS_FILE, TOKEN_FILE, MODEL_DRIVE_FILE_ID)
symbol_deposit = {symbol: float(os.getenv("DEPOSIT_USDT", "1000")) for symbol in DEFAULT_SYMBOLS}

stop_event = threading.Event()
agent_runner = TradingAgentRunner(supervisor, environment, executor, cloud_manager, symbol_deposit)


def start_background_thread():
    if not hasattr(start_background_thread, "thread") or not start_background_thread.thread.is_alive():  # type: ignore[attr-defined]
        start_background_thread.thread = threading.Thread(  # type: ignore[attr-defined]
            target=agent_runner.run,
            name="TradingAgentThread",
            args=(stop_event,),
            daemon=True,
        )
        start_background_thread.thread.start()  # type: ignore[attr-defined]
        logger.info("–§–æ–Ω–æ–≤–∏–π –∞–≥–µ–Ω—Ç –∑–∞–ø—É—â–µ–Ω–æ")


@app.route("/", methods=["GET"])
def healthcheck():
    start_background_thread()
    return jsonify({"status": "ok", "timestamp": datetime.now(timezone.utc).isoformat()})


@app.route("/supervisor", methods=["GET"])
def get_supervisor():
    return jsonify(
        {
            "user_mode": supervisor.user_selected.value,
            "current_band": supervisor.current_band.value,
            "max_position_fraction": supervisor.current_band.max_position_fraction,
        }
    )


@app.route("/config", methods=["POST"])
def update_config():
    payload = request.get_json(force=True, silent=True) or {}
    symbols = payload.get("symbols")
    if symbols and isinstance(symbols, list):
        environment.symbols = symbols
    poll_interval = payload.get("poll_interval_seconds")
    if poll_interval:
        global POLL_INTERVAL_SECONDS  # noqa: PLW0603
        POLL_INTERVAL_SECONDS = int(poll_interval)
    return jsonify({"updated": True, "symbols": environment.symbols, "poll": POLL_INTERVAL_SECONDS})


@app.route("/shutdown", methods=["POST"])
def shutdown_agent():
    stop_event.set()
    return jsonify({"status": "stopping"})


# ------------------------------------------------------------------------------
# Entrypoint
# ------------------------------------------------------------------------------


def create_app() -> Flask:
    return app


if __name__ == "__main__":
    start_background_thread()
    app.run(host="0.0.0.0", port=int(os.getenv("PORT", "8000")))
"""
Streamlit –≤–µ–±-—ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è —Å–∏—Å—Ç–µ–º–∏ –∞—Ä–±—ñ—Ç—Ä–∞–∂—É
"""

import streamlit as st
import asyncio
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import json

from config import Config
from main import TradingBot


class ArbitrageApp:
    """–ì–æ–ª–æ–≤–Ω–∏–π –∫–ª–∞—Å Streamlit –¥–æ–¥–∞—Ç–∫—É"""
    
    def __init__(self):
        self.config = Config()
        self.system = None
        self.setup_page()
    
    def setup_page(self):
        """–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Å—Ç–æ—Ä—ñ–Ω–∫–∏"""
        st.set_page_config(
            page_title="–°–∏—Å—Ç–µ–º–∞ –ê—Ä–±—ñ—Ç—Ä–∞–∂—É",
            page_icon="üí∞",
            layout="wide",
            initial_sidebar_state="expanded"
        )
        
        st.title("üöÄ –°–∏—Å—Ç–µ–º–∞ –ú—ñ–∂–±—ñ—Ä–∂–æ–≤–æ–≥–æ –ê—Ä–±—ñ—Ç—Ä–∞–∂—É")
        st.markdown("---")
    
    def run(self):
        """–ó–∞–ø—É—Å–∫ –¥–æ–¥–∞—Ç–∫—É"""
        # –ë–æ–∫–æ–≤–∞ –ø–∞–Ω–µ–ª—å
        self.render_sidebar()
        
        # –û—Å–Ω–æ–≤–Ω–∞ –ø–∞–Ω–µ–ª—å
        self.render_main_panel()
    
    def render_sidebar(self):
        """–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –±–æ–∫–æ–≤–æ—ó –ø–∞–Ω–µ–ª—ñ"""
        with st.sidebar:
            st.header("üéõÔ∏è –£–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è")
            
            # –°—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º–∏
            if self.system:
                status = self.system.get_status()
                if status['is_running']:
                    st.success("üü¢ –°–∏—Å—Ç–µ–º–∞ –∞–∫—Ç–∏–≤–Ω–∞")
                    st.info(f"–ê–∫—Ç–∏–≤–Ω–∏–π –º–æ–¥—É–ª—å: {status['active_module']}")
                else:
                    st.error("üî¥ –°–∏—Å—Ç–µ–º–∞ –∑—É–ø–∏–Ω–µ–Ω–∞")
            else:
                st.warning("‚ö†Ô∏è –°–∏—Å—Ç–µ–º–∞ –Ω–µ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–∞")
            
            st.markdown("---")
            
            # –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è
            col1, col2 = st.columns(2)
            
            with col1:
                if st.button("‚ñ∂Ô∏è –ó–∞–ø—É—Å—Ç–∏—Ç–∏", key="start_btn"):
                    self.start_system()
            
            with col2:
                if st.button("‚èπÔ∏è –ó—É–ø–∏–Ω–∏—Ç–∏", key="stop_btn"):
                    self.stop_system()
            
            st.markdown("---")
            
            # –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è
            st.header("‚öôÔ∏è –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è")
            
            # –£–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è —Ä–∏–∑–∏–∫–∞–º–∏
            st.subheader("üõ°Ô∏è –†–∏–∑–∏–∫–∏")
            max_position = st.number_input(
                "–ú–∞–∫—Å. —Ä–æ–∑–º—ñ—Ä –ø–æ–∑–∏—Ü—ñ—ó (USD)",
                min_value=100.0,
                max_value=10000.0,
                value=self.config.RISK.max_position_size,
                step=100.0
            )
            
            max_daily_loss = st.number_input(
                "–ú–∞–∫—Å. –¥–µ–Ω–Ω–∏–π –∑–±–∏—Ç–æ–∫ (USD)",
                min_value=10.0,
                max_value=1000.0,
                value=self.config.RISK.max_daily_loss,
                step=10.0
            )
            
            min_profit = st.number_input(
                "–ú—ñ–Ω. –ø—Ä–∏–±—É—Ç–æ–∫ (%)",
                min_value=0.01,
                max_value=5.0,
                value=self.config.RISK.min_profit_threshold,
                step=0.01
            )
            
            # –ö–æ–ø—ñ—Ç—Ä–µ–π–¥–∏–Ω–≥
            st.subheader("üìã –ö–æ–ø—ñ—Ç—Ä–µ–π–¥–∏–Ω–≥")
            copy_ratio = st.slider(
                "–ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è",
                min_value=0.1,
                max_value=2.0,
                value=self.config.COPY_TRADING.copy_ratio,
                step=0.1
            )
            
            min_copy_profit = st.number_input(
                "–ú—ñ–Ω. –ø—Ä–∏–±—É—Ç–æ–∫ –¥–ª—è –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è (%)",
                min_value=0.1,
                max_value=10.0,
                value=self.config.COPY_TRADING.min_profit_threshold,
                step=0.1
            )
    
    def render_main_panel(self):
        """–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –æ—Å–Ω–æ–≤–Ω–æ—ó –ø–∞–Ω–µ–ª—ñ"""
        # –í–∫–ª–∞–¥–∫–∏
        tab1, tab2, tab3, tab4, tab5 = st.tabs([
            "üìä –î–∞—à–±–æ—Ä–¥", 
            "üí∞ –ê—Ä–±—ñ—Ç—Ä–∞–∂", 
            "üìã –ö–æ–ø—ñ—Ç—Ä–µ–π–¥–∏–Ω–≥", 
            "üîç –°–∫–∞–Ω–µ—Ä —Ä–∏–Ω–∫—É", 
            "üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"
        ])
        
        with tab1:
            self.render_dashboard()
        
        with tab2:
            self.render_arbitrage_tab()
        
        with tab3:
            self.render_copy_trading_tab()
        
        with tab4:
            self.render_market_scanner_tab()
        
        with tab5:
            self.render_statistics_tab()
    
    def render_dashboard(self):
        """–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –¥–∞—à–±–æ—Ä–¥—É"""
        st.header("üìä –ó–∞–≥–∞–ª—å–Ω–∏–π –¥–∞—à–±–æ—Ä–¥")
        
        if not self.system:
            st.warning("‚ö†Ô∏è –°–∏—Å—Ç–µ–º–∞ –Ω–µ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–∞. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å '–ó–∞–ø—É—Å—Ç–∏—Ç–∏' –≤ –±–æ–∫–æ–≤—ñ–π –ø–∞–Ω–µ–ª—ñ.")
            return
        
        status = self.system.get_status()
        
        # –ú–µ—Ç—Ä–∏–∫–∏
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric(
                "–°—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º–∏",
                "üü¢ –ê–∫—Ç–∏–≤–Ω–∞" if status['is_running'] else "üî¥ –ó—É–ø–∏–Ω–µ–Ω–∞",
                delta=None
            )
        
        with col2:
            active_module = status.get('active_module', '–ù–µ–º–∞—î')
            st.metric(
                "–ê–∫—Ç–∏–≤–Ω–∏–π –º–æ–¥—É–ª—å",
                active_module,
                delta=None
            )
        
        with col3:
            # –ó–∞–≥–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            total_trades = sum(
                module_stats.get('stats', {}).get('successful_trades', 0) 
                for module_stats in status.get('modules_status', {}).values()
            )
            st.metric(
                "–í—Å—å–æ–≥–æ —É–≥–æ–¥",
                total_trades,
                delta=None
            )
        
        with col4:
            # –ó–∞–≥–∞–ª—å–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫
            total_profit = sum(
                module_stats.get('stats', {}).get('total_profit', 0) 
                for module_stats in status.get('modules_status', {}).values()
            )
            st.metric(
                "–ó–∞–≥–∞–ª—å–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫",
                f"${total_profit:.2f}",
                delta=None
            )
        
        st.markdown("---")
        
        # –°—Ç–∞—Ç—É—Å –º–æ–¥—É–ª—ñ–≤
        st.subheader("üîß –°—Ç–∞—Ç—É—Å –º–æ–¥—É–ª—ñ–≤")
        
        modules_data = []
        for module_name, module_status in status.get('modules_status', {}).items():
            modules_data.append({
                '–ú–æ–¥—É–ª—å': module_name,
                '–Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ': '‚úÖ' if module_status.get('is_initialized') else '‚ùå',
                '–ü—Ä–∞—Ü—é—î': '‚úÖ' if module_status.get('is_running') else '‚ùå',
                '–£–≥–æ–¥–∏': module_status.get('stats', {}).get('successful_trades', 0),
                '–ü—Ä–∏–±—É—Ç–æ–∫': f"${module_status.get('stats', {}).get('total_profit', 0):.2f}",
                '–û—Å—Ç–∞–Ω–Ω—î –æ–Ω–æ–≤–ª–µ–Ω–Ω—è': module_status.get('last_update', '–ù–µ–º–∞—î')
            })
        
        if modules_data:
            df_modules = pd.DataFrame(modules_data)
            st.dataframe(df_modules, use_container_width=True)
        else:
            st.info("üìù –ù–µ–º–∞—î –¥–∞–Ω–∏—Ö –ø—Ä–æ –º–æ–¥—É–ª—ñ")
    
    def render_arbitrage_tab(self):
        """–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –≤–∫–ª–∞–¥–∫–∏ –∞—Ä–±—ñ—Ç—Ä–∞–∂—É"""
        st.header("üí∞ –ú—ñ–∂–±—ñ—Ä–∂–æ–≤–∏–π –∞—Ä–±—ñ—Ç—Ä–∞–∂")
        
        if not self.system:
            st.warning("‚ö†Ô∏è –°–∏—Å—Ç–µ–º–∞ –Ω–µ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–∞")
            return
        
        # –ü–æ—Ç–æ—á–Ω—ñ –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ
        st.subheader("üéØ –ü–æ—Ç–æ—á–Ω—ñ –∞—Ä–±—ñ—Ç—Ä–∞–∂–Ω—ñ –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ")
        
        # Mock –¥–∞–Ω—ñ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü—ñ—ó
        opportunities_data = [
            {
                '–ü–∞—Ä–∞': 'BTC/USDT',
                '–ö—É–ø—ñ–≤–ª—è': 'Binance',
                '–ü—Ä–æ–¥–∞–∂': 'Bybit',
                '–¶—ñ–Ω–∞ –∫—É–ø—ñ–≤–ª—ñ': 50000.0,
                '–¶—ñ–Ω–∞ –ø—Ä–æ–¥–∞–∂—É': 50050.0,
                '–°–ø—Ä–µ–¥ (%)': 0.1,
                '–ß–∏—Å—Ç–∏–π –ø—Ä–∏–±—É—Ç–æ–∫ (%)': 0.08,
                '–û–±—Å—è–≥': 1000.0
            },
            {
                '–ü–∞—Ä–∞': 'ETH/USDT',
                '–ö—É–ø—ñ–≤–ª—è': 'KuCoin',
                '–ü—Ä–æ–¥–∞–∂': 'Binance',
                '–¶—ñ–Ω–∞ –∫—É–ø—ñ–≤–ª—ñ': 3000.0,
                '–¶—ñ–Ω–∞ –ø—Ä–æ–¥–∞–∂—É': 3005.0,
                '–°–ø—Ä–µ–¥ (%)': 0.17,
                '–ß–∏—Å—Ç–∏–π –ø—Ä–∏–±—É—Ç–æ–∫ (%)': 0.15,
                '–û–±—Å—è–≥': 500.0
            }
        ]
        
        df_opportunities = pd.DataFrame(opportunities_data)
        st.dataframe(df_opportunities, use_container_width=True)
        
        # –ì—Ä–∞—Ñ—ñ–∫ —Å–ø—Ä–µ–¥—ñ–≤
        st.subheader("üìà –ì—Ä–∞—Ñ—ñ–∫ —Å–ø—Ä–µ–¥—ñ–≤")
        
        fig = px.bar(
            df_opportunities, 
            x='–ü–∞—Ä–∞', 
            y='–°–ø—Ä–µ–¥ (%)',
            title='–ê—Ä–±—ñ—Ç—Ä–∞–∂–Ω—ñ —Å–ø—Ä–µ–¥–∏ –ø–æ –ø–∞—Ä–∞—Ö',
            color='–ß–∏—Å—Ç–∏–π –ø—Ä–∏–±—É—Ç–æ–∫ (%)',
            color_continuous_scale='RdYlGn'
        )
        st.plotly_chart(fig, use_container_width=True)
    
    def render_copy_trading_tab(self):
        """–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –≤–∫–ª–∞–¥–∫–∏ –∫–æ–ø—ñ—Ç—Ä–µ–π–¥–∏–Ω–≥—É"""
        st.header("üìã –ö–æ–ø—ñ—Ç—Ä–µ–π–¥–∏–Ω–≥ –∑ Traiex")
        
        if not self.system:
            st.warning("‚ö†Ô∏è –°–∏—Å—Ç–µ–º–∞ –Ω–µ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–∞")
            return
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞
        st.subheader("ü§ñ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞ Traiex")
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("–í—Å—å–æ–≥–æ —É–≥–æ–¥", "150", delta="+5")
        
        with col2:
            st.metric("–ü—Ä–∏–±—É—Ç–∫–æ–≤–∏—Ö —É–≥–æ–¥", "95", delta="+3")
        
        with col3:
            st.metric("Win Rate", "63.3%", delta="+2.1%")
        
        with col4:
            st.metric("–ó–∞–≥–∞–ª—å–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫", "$1,250.50", delta="+$45.20")
        
        # –û—Å—Ç–∞–Ω–Ω—ñ —Å–∫–æ–ø—ñ–π–æ–≤–∞–Ω—ñ —É–≥–æ–¥–∏
        st.subheader("üìã –û—Å—Ç–∞–Ω–Ω—ñ —Å–∫–æ–ø—ñ–π–æ–≤–∞–Ω—ñ —É–≥–æ–¥–∏")
        
        copied_trades_data = [
            {
                '–ß–∞—Å': '2024-01-15 14:30:25',
                '–ü–∞—Ä–∞': 'BTC/USDT',
                '–°—Ç–æ—Ä–æ–Ω–∞': '–ö—É–ø—ñ–≤–ª—è',
                '–û–±—Å—è–≥': 0.1,
                '–¶—ñ–Ω–∞': 50000.0,
                '–ë—ñ—Ä–∂–∞': 'Binance',
                '–°—Ç–∞—Ç—É—Å': '–í–∏–∫–æ–Ω–∞–Ω–æ'
            },
            {
                '–ß–∞—Å': '2024-01-15 14:25:10',
                '–ü–∞—Ä–∞': 'ETH/USDT',
                '–°—Ç–æ—Ä–æ–Ω–∞': '–ü—Ä–æ–¥–∞–∂',
                '–û–±—Å—è–≥': 1.0,
                '–¶—ñ–Ω–∞': 3000.0,
                '–ë—ñ—Ä–∂–∞': 'Bybit',
                '–°—Ç–∞—Ç—É—Å': '–í–∏–∫–æ–Ω–∞–Ω–æ'
            }
        ]
        
        df_copied = pd.DataFrame(copied_trades_data)
        st.dataframe(df_copied, use_container_width=True)
    
    def render_market_scanner_tab(self):
        """–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –≤–∫–ª–∞–¥–∫–∏ —Å–∫–∞–Ω–µ—Ä–∞ —Ä–∏–Ω–∫—É"""
        st.header("üîç –°–∫–∞–Ω–µ—Ä —Ä–∏–Ω–∫—É")
        
        if not self.system:
            st.warning("‚ö†Ô∏è –°–∏—Å—Ç–µ–º–∞ –Ω–µ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–∞")
            return
        
        # –¢–æ–ø —Ç–æ—Ä–≥–æ–≤—ñ –ø–∞—Ä–∏
        st.subheader("üèÜ –¢–æ–ø —Ç–æ—Ä–≥–æ–≤—ñ –ø–∞—Ä–∏")
        
        top_pairs_data = [
            {'–†–∞–Ω–≥': 1, '–ü–∞—Ä–∞': 'BTC/USDT', '–†–µ–π—Ç–∏–Ω–≥': 8.5, '–õ—ñ–∫–≤—ñ–¥–Ω—ñ—Å—Ç—å': 9.2, '–°–ø—Ä–µ–¥ (%)': 0.15},
            {'–†–∞–Ω–≥': 2, '–ü–∞—Ä–∞': 'ETH/USDT', '–†–µ–π—Ç–∏–Ω–≥': 7.8, '–õ—ñ–∫–≤—ñ–¥–Ω—ñ—Å—Ç—å': 8.5, '–°–ø—Ä–µ–¥ (%)': 0.12},
            {'–†–∞–Ω–≥': 3, '–ü–∞—Ä–∞': 'BNB/USDT', '–†–µ–π—Ç–∏–Ω–≥': 7.2, '–õ—ñ–∫–≤—ñ–¥–Ω—ñ—Å—Ç—å': 7.8, '–°–ø—Ä–µ–¥ (%)': 0.18},
            {'–†–∞–Ω–≥': 4, '–ü–∞—Ä–∞': 'ADA/USDT', '–†–µ–π—Ç–∏–Ω–≥': 6.9, '–õ—ñ–∫–≤—ñ–¥–Ω—ñ—Å—Ç—å': 6.5, '–°–ø—Ä–µ–¥ (%)': 0.25},
            {'–†–∞–Ω–≥': 5, '–ü–∞—Ä–∞': 'SOL/USDT', '–†–µ–π—Ç–∏–Ω–≥': 6.5, '–õ—ñ–∫–≤—ñ–¥–Ω—ñ—Å—Ç—å': 7.1, '–°–ø—Ä–µ–¥ (%)': 0.22}
        ]
        
        df_top_pairs = pd.DataFrame(top_pairs_data)
        st.dataframe(df_top_pairs, use_container_width=True)
        
        # –ì—Ä–∞—Ñ—ñ–∫ —Ä–µ–π—Ç–∏–Ω–≥—ñ–≤
        st.subheader("üìä –ì—Ä–∞—Ñ—ñ–∫ —Ä–µ–π—Ç–∏–Ω–≥—ñ–≤")
        
        fig = px.scatter(
            df_top_pairs,
            x='–õ—ñ–∫–≤—ñ–¥–Ω—ñ—Å—Ç—å',
            y='–°–ø—Ä–µ–¥ (%)',
            size='–†–µ–π—Ç–∏–Ω–≥',
            color='–†–µ–π—Ç–∏–Ω–≥',
            hover_name='–ü–∞—Ä–∞',
            title='–†–µ–π—Ç–∏–Ω–≥ —Ç–æ—Ä–≥–æ–≤–∏—Ö –ø–∞—Ä',
            color_continuous_scale='RdYlGn'
        )
        st.plotly_chart(fig, use_container_width=True)
    
    def render_statistics_tab(self):
        """–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –≤–∫–ª–∞–¥–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
        st.header("üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")
        
        if not self.system:
            st.warning("‚ö†Ô∏è –°–∏—Å—Ç–µ–º–∞ –Ω–µ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–∞")
            return
        
        # –ó–∞–≥–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        st.subheader("üìä –ó–∞–≥–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")
        
        col1, col2 = st.columns(2)
        
        with col1:
            # –ì—Ä–∞—Ñ—ñ–∫ –ø—Ä–∏–±—É—Ç–∫—É –ø–æ –¥–Ω—è—Ö
            dates = pd.date_range(start='2024-01-01', end='2024-01-15', freq='D')
            profits = [25.50, 45.20, 32.10, 67.80, 23.45, 89.30, 56.70, 34.20, 78.90, 45.60, 67.30, 23.80, 56.40, 89.70, 34.50]
            
            fig_profit = px.line(
                x=dates, 
                y=profits,
                title='–ü—Ä–∏–±—É—Ç–æ–∫ –ø–æ –¥–Ω—è—Ö',
                labels={'x': '–î–∞—Ç–∞', 'y': '–ü—Ä–∏–±—É—Ç–æ–∫ (USD)'}
            )
            st.plotly_chart(fig_profit, use_container_width=True)
        
        with col2:
            # –†–æ–∑–ø–æ–¥—ñ–ª —É–≥–æ–¥ –ø–æ –º–æ–¥—É–ª—è—Ö
            modules = ['–ê—Ä–±—ñ—Ç—Ä–∞–∂', '–ö–æ–ø—ñ—Ç—Ä–µ–π–¥–∏–Ω–≥', '–°–∫–∞–Ω–µ—Ä']
            trades_count = [45, 78, 12]
            
            fig_dist = px.pie(
                values=trades_count,
                names=modules,
                title='–†–æ–∑–ø–æ–¥—ñ–ª —É–≥–æ–¥ –ø–æ –º–æ–¥—É–ª—è—Ö'
            )
            st.plotly_chart(fig_dist, use_container_width=True)
        
        # –î–µ—Ç–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        st.subheader("üìã –î–µ—Ç–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")
        
        stats_data = [
            {'–ú–µ—Ç—Ä–∏–∫–∞': '–í—Å—å–æ–≥–æ —É–≥–æ–¥', '–ó–Ω–∞—á–µ–Ω–Ω—è': '135', '–ó–º—ñ–Ω–∞': '+12'},
            {'–ú–µ—Ç—Ä–∏–∫–∞': '–£—Å–ø—ñ—à–Ω–∏—Ö —É–≥–æ–¥', '–ó–Ω–∞—á–µ–Ω–Ω—è': '98', '–ó–º—ñ–Ω–∞': '+8'},
            {'–ú–µ—Ç—Ä–∏–∫–∞': 'Win Rate', '–ó–Ω–∞—á–µ–Ω–Ω—è': '72.6%', '–ó–º—ñ–Ω–∞': '+3.2%'},
            {'–ú–µ—Ç—Ä–∏–∫–∞': '–ó–∞–≥–∞–ª—å–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫', '–ó–Ω–∞—á–µ–Ω–Ω—è': '$1,234.50', '–ó–º—ñ–Ω–∞': '+$156.80'},
            {'–ú–µ—Ç—Ä–∏–∫–∞': '–°–µ—Ä–µ–¥–Ω—ñ–π –ø—Ä–∏–±—É—Ç–æ–∫', '–ó–Ω–∞—á–µ–Ω–Ω—è': '$9.14', '–ó–º—ñ–Ω–∞': '+$1.23'},
            {'–ú–µ—Ç—Ä–∏–∫–∞': '–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫', '–ó–Ω–∞—á–µ–Ω–Ω—è': '$89.30', '–ó–º—ñ–Ω–∞': '–ù–æ–≤–∏–π —Ä–µ–∫–æ—Ä–¥'},
            {'–ú–µ—Ç—Ä–∏–∫–∞': '–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∏–π –∑–±–∏—Ç–æ–∫', '–ó–Ω–∞—á–µ–Ω–Ω—è': '$12.50', '–ó–º—ñ–Ω–∞': '-$2.10'}
        ]
        
        df_stats = pd.DataFrame(stats_data)
        st.dataframe(df_stats, use_container_width=True)
    
    def start_system(self):
        """–ó–∞–ø—É—Å–∫ —Å–∏—Å—Ç–µ–º–∏"""
        try:
            if not self.system:
                self.system = TradingBot()
            
            # –ó–∞–ø—É—Å–∫ –≤ –æ–∫—Ä–µ–º–æ–º—É –ø–æ—Ç–æ—Ü—ñ
            asyncio.create_task(self.system.start())
            st.success("‚úÖ –°–∏—Å—Ç–µ–º–∞ –∑–∞–ø—É—â–µ–Ω–∞!")
            st.rerun()
            
        except Exception as e:
            st.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–∞–ø—É—Å–∫—É —Å–∏—Å—Ç–µ–º–∏: {e}")
    
    def stop_system(self):
        """–ó—É–ø–∏–Ω–∫–∞ —Å–∏—Å—Ç–µ–º–∏"""
        try:
            if self.system:
                asyncio.create_task(self.system.stop())
                st.success("‚úÖ –°–∏—Å—Ç–µ–º–∞ –∑—É–ø–∏–Ω–µ–Ω–∞!")
                st.rerun()
            else:
                st.warning("‚ö†Ô∏è –°–∏—Å—Ç–µ–º–∞ –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞")
                
        except Exception as e:
            st.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –∑—É–ø–∏–Ω–∫–∏ —Å–∏—Å—Ç–µ–º–∏: {e}")


def main():
    """–ì–æ–ª–æ–≤–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è"""
    app = ArbitrageApp()
    app.run()


if __name__ == "__main__":
    main()

```

---

**User**

–ë—É–¥—å –ª–∞—Å–∫–∞ —É–≤–µ—Å—å –ø—Ä–æ–µ–∫—Ç —Ç–∞ —É—Å—ñ —Ñ–∞–π–ª–∏ —Ä–æ–±–∏ –≤ –æ–∫—Ä–µ–º—ñ–π –ø–∞–ø—Ü—ñ. –Ø–∫—É —Å—Ç–≤–æ—Ä–∏ —Å–∞–º–æ—Å—Ç—ñ–π–Ω–æ —Ç–∞ –Ω–∞–¥–∞–π —ó–π –Ω–∞–∑–≤—É "—Ä–æ–∑—É–º–Ω–∏–π –∞–≥–µ–Ω—Ç "

---

**Cursor**

–§–∞–π–ª–∏ –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω—ñ –¥–æ –Ω–æ–≤–æ—ó –ø–∞–ø–∫–∏ `—Ä–æ–∑—É–º–Ω–∏–π –∞–≥–µ–Ω—Ç`. –¢–µ–ø–µ—Ä —É–≤–µ—Å—å –ø—Ä–æ—î–∫—Ç –ª–µ–∂–∏—Ç—å —É `—Ä–æ–∑—É–º–Ω–∏–π –∞–≥–µ–Ω—Ç/app.py` —Ç–∞ `—Ä–æ–∑—É–º–Ω–∏–π –∞–≥–µ–Ω—Ç/requirements.txt`.

